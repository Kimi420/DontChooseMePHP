<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Card.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Card.js" />
              <option name="updatedContent" value="import React from 'react';&#10;&#10;/**&#10; * Card-Komponente für die Anzeige von Spielkarten mit interaktiven Features&#10; */&#10;function Card({ card, onClick, selected, style = {} }) {&#10;  // Basis- und ausgewählte Styles&#10;  const baseStyle = {&#10;    border: '2px solid rgba(255,255,255,0.3)',&#10;    borderRadius: '16px',&#10;    padding: '8px',&#10;    margin: '8px',&#10;    cursor: onClick ? 'pointer' : 'default',&#10;    background: 'rgba(255,255,255,0.95)',&#10;    transition: 'all 0.3s ease',&#10;    boxShadow: '0 8px 16px rgba(0,0,0,0.15)',&#10;    backdropFilter: 'blur(10px)',&#10;    ...style&#10;  };&#10;  const selectedStyle = {&#10;    border: '4px solid #007bff',&#10;    background: 'linear-gradient(135deg, #e3f2fd, #bbdefb)',&#10;    boxShadow: '0 12px 24px rgba(0,123,255,0.3)'&#10;  };&#10;&#10;  // MouseOver/MouseOut Handler&#10;  const handleMouseOver = (e) =&gt; {&#10;    if (onClick) {&#10;      e.currentTarget.style.transform = 'scale(1.08) translateY(-4px)';&#10;      e.currentTarget.style.boxShadow = '0 16px 32px rgba(0,0,0,0.25)';&#10;    }&#10;  };&#10;  const handleMouseOut = (e) =&gt; {&#10;    if (onClick) {&#10;      e.currentTarget.style.transform = selected ? 'scale(1.05)' : 'scale(1)';&#10;      e.currentTarget.style.boxShadow = selected&#10;        ? '0 12px 24px rgba(0,123,255,0.3)'&#10;        : '0 8px 16px rgba(0,0,0,0.15)';&#10;    }&#10;  };&#10;&#10;  // Bild-Styles&#10;  const imgStyle = {&#10;    width: '250px',&#10;    height: '200px',&#10;    objectFit: 'cover',&#10;    borderRadius: '12px',&#10;    display: 'block',&#10;    filter: selected ? 'brightness(1.1) contrast(1.1)' : 'brightness(1)',&#10;    transition: 'filter 0.3s ease'&#10;  };&#10;&#10;  return (&#10;    &lt;div&#10;      onClick={onClick}&#10;      style={selected ? { ...baseStyle, ...selectedStyle } : baseStyle}&#10;      onMouseOver={handleMouseOver}&#10;      onMouseOut={handleMouseOut}&#10;    &gt;&#10;      &lt;img&#10;        src={`/${card.image}`}&#10;        alt={card.title || `Card ${card.id}`}&#10;        style={imgStyle}&#10;        onError={(e) =&gt; {&#10;          // Fallback-Bild falls das Kartenbild nicht geladen werden kann&#10;          e.target.src = `https://placehold.co/250x200/cccccc/666666?text=Card+${card.id}`;&#10;        }}&#10;      /&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;&#10;export default Card;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Card.php">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Card.php" />
              <option name="updatedContent" value="&lt;?php&#10;&#10;/**&#10; * Card-Klasse für eine Dixit-Karte&#10; */&#10;class Card {&#10;    public int $id;&#10;    public string $title;&#10;    public string $image;&#10;&#10;    public function __construct(int $id, string $title, string $image) {&#10;        $this-&gt;id = $id;&#10;        $this-&gt;title = $title;&#10;        $this-&gt;image = $image;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/CardSelectionPhase.php">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/CardSelectionPhase.php" />
              <option name="updatedContent" value="&lt;?php&#10;&#10;require_once 'Player.php';&#10;require_once 'Card.php';&#10;&#10;/**&#10; * CardSelectionPhase-Klasse für die Dixit-Kartenauswahl-Phase&#10; */&#10;class CardSelectionPhase {&#10;    /** @var array&lt;int, Card&gt; */&#10;    private array $selectedCards = [];&#10;&#10;    /**&#10;     * Spieler wählt eine Karte aus seiner Hand aus&#10;     */&#10;    public function selectCard(Player $player, Card $card): void {&#10;        $this-&gt;selectedCards[$player-&gt;id] = $card;&#10;    }&#10;&#10;    /**&#10;     * Gibt alle ausgewählten Karten zurück&#10;     */&#10;    public function getSelectedCards(): array {&#10;        return $this-&gt;selectedCards;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Game.php">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Game.php" />
              <option name="updatedContent" value="&lt;?php&#10;&#10;require_once 'Player.php';&#10;require_once 'Card.php';&#10;require_once 'StorytellingPhase.php';&#10;require_once 'CardSelectionPhase.php';&#10;require_once 'VotingPhase.php';&#10;require_once 'ScoringPhase.php';&#10;&#10;class Game {&#10;    public string $gameId;&#10;    /** @var Player[] */&#10;    public array $players = [];&#10;    public int $storytellerIndex = 0;&#10;    public string $phase = 'waiting';&#10;    public array $selectedCards = [];&#10;    public array $votes = [];&#10;    public ?string $hint = null;&#10;    public ?int $storytellerCard = null;&#10;    public ?string $winner = null;&#10;    public array $mixedCards = [];&#10;    public string $state = 'waiting';&#10;&#10;    public function __construct(string $gameId, array $players) {&#10;        $this-&gt;gameId = $gameId;&#10;        $this-&gt;players = $players;&#10;    }&#10;&#10;    public function getState(): array {&#10;        return [&#10;            'gameId' =&gt; $this-&gt;gameId,&#10;            'players' =&gt; $this-&gt;players,&#10;            'storytellerIndex' =&gt; $this-&gt;storytellerIndex,&#10;            'phase' =&gt; $this-&gt;phase,&#10;            'selectedCards' =&gt; $this-&gt;selectedCards,&#10;            'votes' =&gt; $this-&gt;votes,&#10;            'hint' =&gt; $this-&gt;hint,&#10;            'storytellerCard' =&gt; $this-&gt;storytellerCard,&#10;            'winner' =&gt; $this-&gt;winner,&#10;            'mixedCards' =&gt; $this-&gt;mixedCards,&#10;            'state' =&gt; $this-&gt;state&#10;        ];&#10;    }&#10;&#10;    public function startGame(): void {&#10;        $this-&gt;phase = 'storytelling';&#10;        $this-&gt;state = 'playing';&#10;        $this-&gt;storytellerIndex = 0;&#10;    }&#10;&#10;    public function giveHint(string $playerName, int $cardId, string $hint): bool {&#10;        $storyteller = $this-&gt;players[$this-&gt;storytellerIndex] ?? null;&#10;        if ($storyteller &amp;&amp; $storyteller-&gt;name === $playerName) {&#10;            $this-&gt;hint = $hint;&#10;            $this-&gt;storytellerCard = $cardId;&#10;            $this-&gt;phase = 'selectCards';&#10;            return true;&#10;        }&#10;        return false;&#10;    }&#10;&#10;    public function chooseCard(string $playerName, int $cardId): bool {&#10;        foreach ($this-&gt;players as $player) {&#10;            if ($player-&gt;name === $playerName) {&#10;                $this-&gt;selectedCards[] = [&#10;                    'playerId' =&gt; $player-&gt;id,&#10;                    'cardId' =&gt; $cardId&#10;                ];&#10;                break;&#10;            }&#10;        }&#10;        // Wenn alle Spieler (außer Erzähler) gewählt haben, nächste Phase&#10;        if (count($this-&gt;selectedCards) &gt;= count($this-&gt;players) - 1) {&#10;            $this-&gt;phase = 'voting';&#10;        }&#10;        return true;&#10;    }&#10;&#10;    public function vote(string $playerName, int $cardId): bool {&#10;        foreach ($this-&gt;players as $player) {&#10;            if ($player-&gt;name === $playerName) {&#10;                // Spieler darf nicht für eigene Karte stimmen&#10;                $ownCard = array_filter($this-&gt;selectedCards, fn($sc) =&gt; $sc['playerId'] === $player-&gt;id &amp;&amp; $sc['cardId'] === $cardId);&#10;                if ($ownCard) return false;&#10;                $this-&gt;votes[] = [&#10;                    'playerId' =&gt; $player-&gt;id,&#10;                    'cardId' =&gt; $cardId&#10;                ];&#10;                break;&#10;            }&#10;        }&#10;        // Wenn alle Stimmen abgegeben, nächste Phase&#10;        if (count($this-&gt;votes) &gt;= count($this-&gt;players) - 1) {&#10;            $this-&gt;phase = 'reveal';&#10;        }&#10;        return true;&#10;    }&#10;&#10;    public function nextRound(): void {&#10;        // Punkte berechnen&#10;        $scoring = new ScoringPhase();&#10;        $scoring-&gt;calculateScores($this-&gt;players, $this-&gt;storytellerCard, array_column($this-&gt;votes, 'cardId'));&#10;        // Erzähler wechseln&#10;        $this-&gt;storytellerIndex = ($this-&gt;storytellerIndex + 1) % count($this-&gt;players);&#10;        // Reset für neue Runde&#10;        $this-&gt;phase = 'storytelling';&#10;        $this-&gt;selectedCards = [];&#10;        $this-&gt;votes = [];&#10;        $this-&gt;hint = null;&#10;        $this-&gt;storytellerCard = null;&#10;    }&#10;&#10;    public function restart(): void {&#10;        foreach ($this-&gt;players as $player) {&#10;            $player-&gt;score = 0;&#10;        }&#10;        $this-&gt;phase = 'waiting';&#10;        $this-&gt;state = 'waiting';&#10;        $this-&gt;selectedCards = [];&#10;        $this-&gt;votes = [];&#10;        $this-&gt;hint = null;&#10;        $this-&gt;storytellerCard = null;&#10;        $this-&gt;winner = null;&#10;        $this-&gt;storytellerIndex = 0;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Lobby.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Lobby.js" />
              <option name="updatedContent" value="import React from 'react';&#10;import './LobbyStyle.css';&#10;&#10;function Lobby({ players, gameId, error, onJoin, onStart, onLeave }) {&#10;  return (&#10;    &lt;div className=&quot;lobby-container&quot;&gt;&#10;      &lt;h2&gt; Raum: {gameId}&lt;/h2&gt;&#10;      &lt;div className=&quot;lobby-players&quot;&gt;&#10;        &lt;h3&gt; Spieler ({players.length})&lt;/h3&gt;&#10;        &lt;div style={{ display: 'grid', gap: '12px', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))' }}&gt;&#10;          {players.map((player, idx) =&gt; (&#10;            &lt;div key={player.id} className=&quot;lobby-player-card&quot;&gt;&#10;              &lt;div style={{ fontSize: '24px', marginBottom: '8px' }}&gt;&#10;                {idx === 0 ? '' : ''}&#10;              &lt;/div&gt;&#10;              &lt;div style={{ fontWeight: 'bold', fontSize: '16px' }}&gt;{player.name}&lt;/div&gt;&#10;              {idx === 0 &amp;&amp; &lt;div style={{ color: '#FFD700', fontSize: '12px', marginTop: '4px', fontWeight: 'bold' }}&gt;Raumleiter&lt;/div&gt;}&#10;            &lt;/div&gt;&#10;          ))}&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;      {error &amp;&amp; &lt;div className=&quot;lobby-error&quot;&gt;⚠️ {error}&lt;/div&gt;}&#10;      &lt;button className=&quot;lobby-btn&quot; onClick={onJoin}&gt; Raum beitreten&lt;/button&gt;&#10;      &lt;button className=&quot;lobby-btn&quot; onClick={onStart} disabled={players.length &lt; 3}&gt; Spiel starten!&lt;/button&gt;&#10;      &lt;button className=&quot;lobby-btn&quot; onClick={onLeave}&gt; Verlassen&lt;/button&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;&#10;export default Lobby;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Lobby.php">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Lobby.php" />
              <option name="updatedContent" value="&lt;?php&#10;&#10;require_once 'Player.php';&#10;&#10;/**&#10; * Lobby-Klasse für die Verwaltung der Spiel-Lobby&#10; */&#10;class Lobby {&#10;    private string $gameId;&#10;    /** @var Player[] */&#10;    private array $players = [];&#10;    private string $state = 'waiting'; // 'waiting' oder 'playing'&#10;&#10;    public function __construct(string $gameId) {&#10;        $this-&gt;gameId = $gameId;&#10;    }&#10;&#10;    /**&#10;     * Spieler tritt der Lobby bei&#10;     */&#10;    public function joinLobby(Player $player): bool {&#10;        foreach ($this-&gt;players as $p) {&#10;            if ($p-&gt;name === $player-&gt;name) {&#10;                return false; // Name schon vergeben&#10;            }&#10;        }&#10;        $this-&gt;players[] = $player;&#10;        return true;&#10;    }&#10;&#10;    /**&#10;     * Spieler verlässt die Lobby&#10;     */&#10;    public function leaveLobby(string $playerName): void {&#10;        $this-&gt;players = array_filter($this-&gt;players, fn($p) =&gt; $p-&gt;name !== $playerName);&#10;    }&#10;&#10;    /**&#10;     * Gibt den aktuellen Lobby-Status zurück&#10;     */&#10;    public function getState(): array {&#10;        return [&#10;            'gameId' =&gt; $this-&gt;gameId,&#10;            'players' =&gt; array_map(fn($p) =&gt; ['id' =&gt; $p-&gt;id, 'name' =&gt; $p-&gt;name], $this-&gt;players),&#10;            'state' =&gt; $this-&gt;state&#10;        ];&#10;    }&#10;&#10;    /**&#10;     * Startet das Spiel, wenn genug Spieler vorhanden sind&#10;     */&#10;    public function startGame(): bool {&#10;        if (count($this-&gt;players) &gt;= 3) {&#10;            $this-&gt;state = 'playing';&#10;            return true;&#10;        }&#10;        return false;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/LobbyStyle.css">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/LobbyStyle.css" />
              <option name="updatedContent" value="&#10;.lobby-container {&#10;    background: rgba(255,255,255,0.1);&#10;    border-radius: 16px;&#10;    padding: 20px;&#10;    margin-bottom: 24px;&#10;    border: 1px solid rgba(255,255,255,0.2);&#10;    text-align: center;&#10;}&#10;&#10;.lobby-players {&#10;    background: rgba(255,255,255,0.1);&#10;    border-radius: 16px;&#10;    padding: 24px;&#10;    margin-bottom: 24px;&#10;    border: 1px solid rgba(255,255,255,0.2);&#10;}&#10;&#10;.lobby-player-card {&#10;    background: linear-gradient(135deg, rgba(255,255,255,0.2), rgba(255,255,255,0.1));&#10;    padding: 16px;&#10;    border-radius: 12px;&#10;    border: 1px solid rgba(255,255,255,0.3);&#10;    text-align: center;&#10;    backdrop-filter: blur(10px);&#10;}&#10;&#10;.lobby-btn {&#10;    padding: 16px 24px;&#10;    font-size: 18px;&#10;    font-weight: bold;&#10;    border-radius: 12px;&#10;    cursor: pointer;&#10;    transition: all 0.3s ease;&#10;    border: none;&#10;    color: white;&#10;    background: linear-gradient(135deg, #00c6ff, #0072ff);&#10;    box-shadow: 0 6px 20px rgba(0,114,255,0.3);&#10;    margin: 8px;&#10;}&#10;&#10;.lobby-btn:disabled {&#10;    background: linear-gradient(135deg, #6c757d, #5a6268);&#10;    cursor: not-allowed;&#10;    box-shadow: 0 4px 12px rgba(108,117,125,0.3);&#10;}&#10;&#10;.lobby-error {&#10;    background: linear-gradient(135deg, #ff6b6b, #ee5a52);&#10;    color: white;&#10;    padding: 12px 20px;&#10;    border-radius: 12px;&#10;    margin-bottom: 20px;&#10;    text-align: center;&#10;    font-weight: bold;&#10;    box-shadow: 0 4px 12px rgba(255,107,107,0.3);&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Player.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Player.js" />
              <option name="updatedContent" value="/**&#10; * Player-Klasse für einen Dixit-Spieler&#10; */&#10;class Player {&#10;  constructor({ id, name, score = 0, hand = [], isActive = false, isStoryteller = false }) {&#10;    this.id = id;&#10;    this.name = name;&#10;    this.score = score;&#10;    this.hand = hand; // Array von Kartenobjekten&#10;    this.isActive = isActive; // Ist der Spieler gerade am Zug?&#10;    this.isStoryteller = isStoryteller; // Ist der Spieler der aktuelle Storyteller?&#10;  }&#10;}&#10;&#10;export default Player;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Player.php">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Player.php" />
              <option name="updatedContent" value="&lt;?php&#10;&#10;require_once 'Card.php';&#10;&#10;/**&#10; * Player-Klasse für einen Dixit-Spieler&#10; */&#10;class Player {&#10;    public int $id;&#10;    public string $name;&#10;    public int $score;&#10;    /** @var Card[] */&#10;    public array $hand;&#10;    public bool $isActive;&#10;    public bool $isStoryteller;&#10;&#10;    public function __construct(&#10;        int $id,&#10;        string $name,&#10;        int $score = 0,&#10;        array $hand = [],&#10;        bool $isActive = false,&#10;        bool $isStoryteller = false&#10;    ) {&#10;        $this-&gt;id = $id;&#10;        $this-&gt;name = $name;&#10;        $this-&gt;score = $score;&#10;        $this-&gt;hand = $hand;&#10;        $this-&gt;isActive = $isActive;&#10;        $this-&gt;isStoryteller = $isStoryteller;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ScoringPhase.php">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ScoringPhase.php" />
              <option name="updatedContent" value="&lt;?php&#10;&#10;require_once 'Player.php';&#10;require_once 'Card.php';&#10;&#10;/**&#10; * ScoringPhase-Klasse für die Dixit-Auswertungsphase&#10; */&#10;class ScoringPhase {&#10;    /**&#10;     * Berechnet und vergibt Punkte an die Spieler&#10;     * @param Player[] $players&#10;     * @param int $storytellerCardId&#10;     * @param array&lt;int, int&gt; $votes&#10;     */&#10;    public function calculateScores(array $players, int $storytellerCardId, array $votes): void {&#10;        // Beispielhafte Punktevergabe nach Dixit-Regeln&#10;        $storytellerFound = false;&#10;        $voteCounts = array_count_values($votes);&#10;&#10;        foreach ($players as $player) {&#10;            if (isset($votes[$player-&gt;id]) &amp;&amp; $votes[$player-&gt;id] === $storytellerCardId) {&#10;                $player-&gt;score += 3;&#10;                $storytellerFound = true;&#10;            }&#10;        }&#10;&#10;        // Storyteller bekommt Punkte, wenn nicht alle oder keiner richtig gewählt hat&#10;        if ($storytellerFound &amp;&amp; count($voteCounts) &gt; 1) {&#10;            foreach ($players as $player) {&#10;                if (isset($votes[$player-&gt;id]) &amp;&amp; $votes[$player-&gt;id] !== $storytellerCardId) {&#10;                    // Bonuspunkte für Spieler, deren Karte gewählt wurde&#10;                    $player-&gt;score += $voteCounts[$votes[$player-&gt;id]] ?? 0;&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/StorytellingPhase.php">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/StorytellingPhase.php" />
              <option name="updatedContent" value="&lt;?php&#10;&#10;require_once 'Player.php';&#10;require_once 'Card.php';&#10;&#10;/**&#10; * StorytellingPhase-Klasse für die Dixit-Storytelling-Phase&#10; */&#10;class StorytellingPhase {&#10;    private Player $storyteller;&#10;    private Card $chosenCard;&#10;    private string $hint;&#10;&#10;    public function __construct(Player $storyteller) {&#10;        $this-&gt;storyteller = $storyteller;&#10;    }&#10;&#10;    public function start(string $hint, Card $card) {&#10;        $this-&gt;hint = $hint;&#10;        $this-&gt;chosenCard = $card;&#10;        $this-&gt;storyteller-&gt;isStoryteller = true;&#10;    }&#10;&#10;    public function getHint(): string {&#10;        return $this-&gt;hint;&#10;    }&#10;&#10;    public function getChosenCard(): Card {&#10;        return $this-&gt;chosenCard;&#10;    }&#10;&#10;    public function getStoryteller(): Player {&#10;        return $this-&gt;storyteller;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/VotingPhase.php">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/VotingPhase.php" />
              <option name="updatedContent" value="&lt;?php&#10;&#10;require_once 'Player.php';&#10;require_once 'Card.php';&#10;&#10;/**&#10; * VotingPhase-Klasse für die Dixit-Abstimmungsphase&#10; */&#10;class VotingPhase {&#10;    /** @var array&lt;int, int&gt; */&#10;    private array $votes = [];&#10;&#10;    /**&#10;     * Spieler stimmt für eine Karte ab&#10;     */&#10;    public function vote(Player $player, int $cardId): void {&#10;        $this-&gt;votes[$player-&gt;id] = $cardId;&#10;    }&#10;&#10;    /**&#10;     * Gibt alle Stimmen zurück&#10;     */&#10;    public function getVotes(): array {&#10;        return $this-&gt;votes;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/.gitignore">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/.gitignore" />
              <option name="originalContent" value="# Konfigurationsdateien&#10;config.php&#10;.env&#10;&#10;# Log-Dateien&#10;*.log&#10;&#10;# Temporäre Dateien&#10;*.tmp&#10;&#10;" />
              <option name="updatedContent" value="# Konfigurationsdateien&#10;config.php&#10;.env&#10;database.php&#10;../config/&#10;&#10;# Log-Dateien&#10;*.log&#10;&#10;# Temporäre Dateien&#10;*.tmp&#10;&#10;# Backup-Dateien&#10;*.bak&#10;*~" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/.htaccess">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/.htaccess" />
              <option name="originalContent" value="# CORS und PHP-API für Backend&#10;&#10;&#10;# PHP-Fehler nicht als HTML anzeigen&#10;php_flag display_errors off&#10;php_flag log_errors on&#10;&#10;RewriteEngine On&#10;&#10;# Nur API-Endpunkte umleiten, aber nur wenn keine Datei/Verzeichnis existiert&#10;RewriteCond %{REQUEST_FILENAME} !-f&#10;RewriteCond %{REQUEST_FILENAME} !-d&#10;RewriteRule ^api/(.*)$ index.php [L]&#10;" />
              <option name="updatedContent" value="# CORS und PHP-API für Backend&#10;&#10;&#10;# PHP-Fehler nicht als HTML anzeigen&#10;php_flag display_errors off&#10;php_flag log_errors on&#10;&#10;RewriteEngine On&#10;&#10;# Nur API-Endpunkte umleiten, aber nur wenn keine Datei/Verzeichnis existiert&#10;RewriteCond %{REQUEST_FILENAME} !-f&#10;RewriteCond %{REQUEST_FILENAME} !-d&#10;RewriteRule ^api/(.*)$ index.php [L]&#10;&#10;# Zugriff auf Konfigurationsdateien verbieten&#10;&lt;Files &quot;config.php&quot;&gt;&#10;    Order allow,deny&#10;    Deny from all&#10;&lt;/Files&gt;&#10;&#10;&lt;Files &quot;database.php&quot;&gt;&#10;    Order allow,deny&#10;    Deny from all&#10;&lt;/Files&gt;&#10;&#10;# PHP-Dateien nur über bestimmte Endpunkte erlauben&#10;&lt;FilesMatch &quot;^(?!(Lobby|Game_api)\.php$).*\.php$&quot;&gt;&#10;    Order allow,deny&#10;    Deny from all&#10;&lt;/FilesMatch&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/Database.php">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/Database.php" />
              <option name="originalContent" value="&lt;?php&#10;&#10;class Database {&#10;    private static ?PDO $connection = null;&#10;    &#10;    public static function getConnection(): PDO {&#10;        if (self::$connection === null) {&#10;            $config = require_once 'config.php';&#10;            &#10;            $dsn = &quot;mysql:host={$config['DB_HOST']};dbname={$config['DB_NAME']};charset={$config['DB_CHARSET']}&quot;;&#10;            &#10;            try {&#10;                self::$connection = new PDO(&#10;                    $dsn,&#10;                    $config['DB_USER'],&#10;                    $config['DB_PASS'],&#10;                    [&#10;                        PDO::ATTR_ERRMODE =&gt; PDO::ERRMODE_EXCEPTION,&#10;                        PDO::ATTR_DEFAULT_FETCH_MODE =&gt; PDO::FETCH_ASSOC,&#10;                        PDO::ATTR_EMULATE_PREPARES =&gt; false&#10;                    ]&#10;                );&#10;                &#10;                // Tabellen erstellen falls sie nicht existieren&#10;                self::createTables();&#10;                &#10;            } catch (PDOException $e) {&#10;                error_log(&quot;Datenbankverbindung fehlgeschlagen: &quot; . $e-&gt;getMessage());&#10;                throw new Exception(&quot;Datenbankverbindung fehlgeschlagen&quot;);&#10;            }&#10;        }&#10;        &#10;        return self::$connection;&#10;    }&#10;    &#10;    private static function createTables(): void {&#10;        $pdo = self::$connection;&#10;        &#10;        // Games Tabelle&#10;        $pdo-&gt;exec(&quot;CREATE TABLE IF NOT EXISTS games (&#10;            id VARCHAR(10) PRIMARY KEY,&#10;            state TEXT NOT NULL,&#10;            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,&#10;            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP&#10;        )&quot;);&#10;        &#10;        // Players Tabelle&#10;        $pdo-&gt;exec(&quot;CREATE TABLE IF NOT EXISTS players (&#10;            id INT AUTO_INCREMENT PRIMARY KEY,&#10;            game_id VARCHAR(10) NOT NULL,&#10;            player_id INT NOT NULL,&#10;            name VARCHAR(100) NOT NULL,&#10;            cards TEXT,&#10;            score INT DEFAULT 0,&#10;            FOREIGN KEY (game_id) REFERENCES games(id) ON DELETE CASCADE,&#10;            UNIQUE KEY unique_player_game (game_id, player_id)&#10;        )&quot;);&#10;    }&#10;}&#10;?&gt;&#10;&#10;" />
              <option name="updatedContent" value="&lt;?php&#10;&#10;class Database {&#10;    private static ?PDO $connection = null;&#10;    &#10;    public static function getConnection(): PDO {&#10;        if (self::$connection === null) {&#10;            // Konfiguration außerhalb des Web-Verzeichnisses laden&#10;            $configPath = __DIR__ . '/../config/database.php';&#10;            &#10;            if (!file_exists($configPath)) {&#10;                throw new Exception(&quot;Konfigurationsdatei nicht gefunden: &quot; . $configPath);&#10;            }&#10;            &#10;            $config = require_once $configPath;&#10;            &#10;            $dsn = &quot;mysql:host={$config['DB_HOST']};dbname={$config['DB_NAME']};charset={$config['DB_CHARSET']}&quot;;&#10;            &#10;            try {&#10;                self::$connection = new PDO(&#10;                    $dsn,&#10;                    $config['DB_USER'],&#10;                    $config['DB_PASS'],&#10;                    [&#10;                        PDO::ATTR_ERRMODE =&gt; PDO::ERRMODE_EXCEPTION,&#10;                        PDO::ATTR_DEFAULT_FETCH_MODE =&gt; PDO::FETCH_ASSOC,&#10;                        PDO::ATTR_EMULATE_PREPARES =&gt; false&#10;                    ]&#10;                );&#10;                &#10;                // Tabellen erstellen falls sie nicht existieren&#10;                self::createTables();&#10;                &#10;            } catch (PDOException $e) {&#10;                error_log(&quot;Datenbankverbindung fehlgeschlagen: &quot; . $e-&gt;getMessage());&#10;                throw new Exception(&quot;Datenbankverbindung fehlgeschlagen&quot;);&#10;            }&#10;        }&#10;        &#10;        return self::$connection;&#10;    }&#10;    &#10;    private static function createTables(): void {&#10;        $pdo = self::$connection;&#10;        &#10;        // Games Tabelle&#10;        $pdo-&gt;exec(&quot;CREATE TABLE IF NOT EXISTS games (&#10;            id VARCHAR(10) PRIMARY KEY,&#10;            state TEXT NOT NULL,&#10;            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,&#10;            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP&#10;        )&quot;);&#10;        &#10;        // Players Tabelle&#10;        $pdo-&gt;exec(&quot;CREATE TABLE IF NOT EXISTS players (&#10;            id INT AUTO_INCREMENT PRIMARY KEY,&#10;            game_id VARCHAR(10) NOT NULL,&#10;            player_id INT NOT NULL,&#10;            name VARCHAR(100) NOT NULL,&#10;            cards TEXT,&#10;            score INT DEFAULT 0,&#10;            FOREIGN KEY (game_id) REFERENCES games(id) ON DELETE CASCADE,&#10;            UNIQUE KEY unique_player_game (game_id, player_id)&#10;        )&quot;);&#10;    }&#10;}&#10;?&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/Game.php">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/Game.php" />
              <option name="originalContent" value="&lt;?php&#10;&#10;header('Access-Control-Allow-Origin: *');&#10;header('Access-Control-Allow-Methods: POST, GET, OPTIONS');&#10;header('Access-Control-Allow-Headers: Content-Type');&#10;if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {&#10;    http_response_code(200);&#10;    exit();&#10;}&#10;&#10;&#10;require_once 'Player.php';&#10;require_once 'Card.php';&#10;require_once 'StorytellingPhase.php';&#10;require_once 'CardSelectionPhase.php';&#10;require_once 'VotingPhase.php';&#10;require_once 'ScoringPhase.php';&#10;&#10;class Game {&#10;    public string $gameId;&#10;    /** @var Player[] */&#10;    public array $players = [];&#10;    public int $storytellerIndex = 0;&#10;    public string $phase = 'waiting';&#10;    public array $selectedCards = [];&#10;    public array $votes = [];&#10;    public ?string $hint = null;&#10;    public ?int $storytellerCard = null;&#10;    public ?string $winner = null;&#10;    public array $mixedCards = [];&#10;    public string $state = 'waiting';&#10;&#10;    public function __construct(string $gameId, array $players) {&#10;        $this-&gt;gameId = $gameId;&#10;        $this-&gt;players = $players;&#10;    }&#10;&#10;    public function getState(): array {&#10;        return [&#10;            'gameId' =&gt; $this-&gt;gameId,&#10;            'players' =&gt; $this-&gt;players,&#10;            'storytellerIndex' =&gt; $this-&gt;storytellerIndex,&#10;            'phase' =&gt; $this-&gt;phase,&#10;            'selectedCards' =&gt; $this-&gt;selectedCards,&#10;            'votes' =&gt; $this-&gt;votes,&#10;            'hint' =&gt; $this-&gt;hint,&#10;            'storytellerCard' =&gt; $this-&gt;storytellerCard,&#10;            'winner' =&gt; $this-&gt;winner,&#10;            'mixedCards' =&gt; $this-&gt;mixedCards,&#10;            'state' =&gt; $this-&gt;state&#10;        ];&#10;    }&#10;&#10;    public function startGame(): void {&#10;        $this-&gt;phase = 'storytelling';&#10;        $this-&gt;state = 'playing';&#10;        // Setze alle Spieler auf nicht Storyteller&#10;        foreach ($this-&gt;players as $player) {&#10;            $player-&gt;isStoryteller = false;&#10;        }&#10;        // Erster Spieler wird Storyteller&#10;        if (count($this-&gt;players) &gt; 0) {&#10;            $this-&gt;players[0]-&gt;isStoryteller = true;&#10;        }&#10;    }&#10;&#10;    public function giveHint(string $playerName, int $cardId, string $hint): bool {&#10;        $storyteller = null;&#10;        foreach ($this-&gt;players as $player) {&#10;            if ($player-&gt;isStoryteller) {&#10;                $storyteller = $player;&#10;                break;&#10;            }&#10;        }&#10;        if ($storyteller &amp;&amp; $storyteller-&gt;name === $playerName) {&#10;            $this-&gt;hint = $hint;&#10;            $this-&gt;storytellerCard = $cardId;&#10;            $this-&gt;phase = 'selectCards';&#10;            return true;&#10;        }&#10;        return false;&#10;    }&#10;&#10;    public function chooseCard(string $playerName, int $cardId): bool {&#10;        foreach ($this-&gt;players as $player) {&#10;            if ($player-&gt;name === $playerName &amp;&amp; !$player-&gt;isStoryteller) {&#10;                $this-&gt;selectedCards[] = [&#10;                    'playerId' =&gt; $player-&gt;id,&#10;                    'cardId' =&gt; $cardId&#10;                ];&#10;                break;&#10;            }&#10;        }&#10;        // Wenn alle Spieler (außer Erzähler) gewählt haben, nächste Phase&#10;        $nonStorytellerCount = 0;&#10;        foreach ($this-&gt;players as $player) {&#10;            if (!$player-&gt;isStoryteller) {&#10;                $nonStorytellerCount++;&#10;            }&#10;        }&#10;        if (count($this-&gt;selectedCards) &gt;= $nonStorytellerCount) {&#10;            $this-&gt;phase = 'voting';&#10;        }&#10;        return true;&#10;    }&#10;&#10;    public function vote(string $playerName, int $cardId): bool {&#10;        foreach ($this-&gt;players as $player) {&#10;            if ($player-&gt;name === $playerName) {&#10;                // Spieler darf nicht für eigene Karte stimmen&#10;                $ownCard = array_filter($this-&gt;selectedCards, fn($sc) =&gt; $sc['playerId'] === $player-&gt;id &amp;&amp; $sc['cardId'] === $cardId);&#10;                if ($ownCard) return false;&#10;                $this-&gt;votes[] = [&#10;                    'playerId' =&gt; $player-&gt;id,&#10;                    'cardId' =&gt; $cardId&#10;                ];&#10;                break;&#10;            }&#10;        }&#10;        // Wenn alle Stimmen abgegeben, nächste Phase&#10;        if (count($this-&gt;votes) &gt;= count($this-&gt;players) - 1) {&#10;            $this-&gt;phase = 'reveal';&#10;        }&#10;        return true;&#10;    }&#10;&#10;    public function nextRound(): void {&#10;        // Punkte berechnen&#10;        $scoring = new ScoringPhase();&#10;        $scoring-&gt;calculateScores($this-&gt;players, $this-&gt;storytellerCard, array_column($this-&gt;votes, 'cardId'));&#10;        // Erzähler wechseln&#10;        $this-&gt;storytellerIndex = ($this-&gt;storytellerIndex + 1) % count($this-&gt;players);&#10;        // Reset für neue Runde&#10;        $this-&gt;phase = 'storytelling';&#10;        $this-&gt;selectedCards = [];&#10;        $this-&gt;votes = [];&#10;        $this-&gt;hint = null;&#10;        $this-&gt;storytellerCard = null;&#10;        // Status der Kartenauswahl für alle Spieler zurücksetzen&#10;        foreach ($this-&gt;players as $player) {&#10;            $player-&gt;hasSelectedCard = false;&#10;        }&#10;    }&#10;&#10;    public function restart(): void {&#10;        foreach ($this-&gt;players as $player) {&#10;            $player-&gt;score = 0;&#10;        }&#10;        $this-&gt;phase = 'waiting';&#10;        $this-&gt;state = 'waiting';&#10;        $this-&gt;selectedCards = [];&#10;        $this-&gt;votes = [];&#10;        $this-&gt;hint = null;&#10;        $this-&gt;storytellerCard = null;&#10;        $this-&gt;winner = null;&#10;        $this-&gt;storytellerIndex = 0;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="&lt;?php&#10;&#10;header('Access-Control-Allow-Origin: *');&#10;header('Access-Control-Allow-Methods: POST, GET, OPTIONS');&#10;header('Access-Control-Allow-Headers: Content-Type');&#10;if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {&#10;    http_response_code(200);&#10;    exit();&#10;}&#10;&#10;&#10;require_once 'Player.php';&#10;require_once 'Card.php';&#10;require_once 'StorytellingPhase.php';&#10;require_once 'CardSelectionPhase.php';&#10;require_once 'VotingPhase.php';&#10;require_once 'ScoringPhase.php';&#10;&#10;class Game {&#10;    public string $gameId;&#10;    /** @var Player[] */&#10;    public array $players = [];&#10;    public int $storytellerIndex = 0;&#10;    public string $phase = 'waiting';&#10;    public array $selectedCards = [];&#10;    public array $votes = [];&#10;    public ?string $hint = null;&#10;    public ?int $storytellerCard = null;&#10;    public ?string $winner = null;&#10;    public array $mixedCards = [];&#10;    public string $state = 'waiting';&#10;    public array $cardData = [];&#10;&#10;    public function __construct(string $gameId, array $cardData = []) {&#10;        $this-&gt;gameId = $gameId;&#10;        $this-&gt;players = [];&#10;        $this-&gt;cardData = $cardData;&#10;    }&#10;&#10;    /**&#10;     * Fügt einen neuen Spieler zum Spiel hinzu&#10;     */&#10;    public function addPlayer(string $playerName): Player {&#10;        $playerId = count($this-&gt;players) + 1;&#10;        $player = new Player($playerId, $playerName);&#10;        $this-&gt;players[] = $player;&#10;        return $player;&#10;    }&#10;&#10;    public function getState(): array {&#10;        return [&#10;            'gameId' =&gt; $this-&gt;gameId,&#10;            'players' =&gt; $this-&gt;players,&#10;            'storytellerIndex' =&gt; $this-&gt;storytellerIndex,&#10;            'phase' =&gt; $this-&gt;phase,&#10;            'selectedCards' =&gt; $this-&gt;selectedCards,&#10;            'votes' =&gt; $this-&gt;votes,&#10;            'hint' =&gt; $this-&gt;hint,&#10;            'storytellerCard' =&gt; $this-&gt;storytellerCard,&#10;            'winner' =&gt; $this-&gt;winner,&#10;            'mixedCards' =&gt; $this-&gt;mixedCards,&#10;            'state' =&gt; $this-&gt;state&#10;        ];&#10;    }&#10;&#10;    public function startGame(): void {&#10;        $this-&gt;phase = 'storytelling';&#10;        $this-&gt;state = 'playing';&#10;        // Setze alle Spieler auf nicht Storyteller&#10;        foreach ($this-&gt;players as $player) {&#10;            $player-&gt;isStoryteller = false;&#10;        }&#10;        // Erster Spieler wird Storyteller&#10;        if (count($this-&gt;players) &gt; 0) {&#10;            $this-&gt;players[0]-&gt;isStoryteller = true;&#10;        }&#10;    }&#10;&#10;    public function giveHint(string $playerName, int $cardId, string $hint): bool {&#10;        $storyteller = null;&#10;        foreach ($this-&gt;players as $player) {&#10;            if ($player-&gt;isStoryteller) {&#10;                $storyteller = $player;&#10;                break;&#10;            }&#10;        }&#10;        if ($storyteller &amp;&amp; $storyteller-&gt;name === $playerName) {&#10;            $this-&gt;hint = $hint;&#10;            $this-&gt;storytellerCard = $cardId;&#10;            $this-&gt;phase = 'selectCards';&#10;            return true;&#10;        }&#10;        return false;&#10;    }&#10;&#10;    public function chooseCard(string $playerName, int $cardId): bool {&#10;        foreach ($this-&gt;players as $player) {&#10;            if ($player-&gt;name === $playerName &amp;&amp; !$player-&gt;isStoryteller) {&#10;                $this-&gt;selectedCards[] = [&#10;                    'playerId' =&gt; $player-&gt;id,&#10;                    'cardId' =&gt; $cardId&#10;                ];&#10;                break;&#10;            }&#10;        }&#10;        // Wenn alle Spieler (außer Erzähler) gewählt haben, nächste Phase&#10;        $nonStorytellerCount = 0;&#10;        foreach ($this-&gt;players as $player) {&#10;            if (!$player-&gt;isStoryteller) {&#10;                $nonStorytellerCount++;&#10;            }&#10;        }&#10;        if (count($this-&gt;selectedCards) &gt;= $nonStorytellerCount) {&#10;            $this-&gt;phase = 'voting';&#10;        }&#10;        return true;&#10;    }&#10;&#10;    public function vote(string $playerName, int $cardId): bool {&#10;        foreach ($this-&gt;players as $player) {&#10;            if ($player-&gt;name === $playerName) {&#10;                // Spieler darf nicht für eigene Karte stimmen&#10;                $ownCard = array_filter($this-&gt;selectedCards, fn($sc) =&gt; $sc['playerId'] === $player-&gt;id &amp;&amp; $sc['cardId'] === $cardId);&#10;                if ($ownCard) return false;&#10;                $this-&gt;votes[] = [&#10;                    'playerId' =&gt; $player-&gt;id,&#10;                    'cardId' =&gt; $cardId&#10;                ];&#10;                break;&#10;            }&#10;        }&#10;        // Wenn alle Stimmen abgegeben, nächste Phase&#10;        if (count($this-&gt;votes) &gt;= count($this-&gt;players) - 1) {&#10;            $this-&gt;phase = 'reveal';&#10;        }&#10;        return true;&#10;    }&#10;&#10;    public function nextRound(): void {&#10;        // Punkte berechnen&#10;        $scoring = new ScoringPhase();&#10;        $scoring-&gt;calculateScores($this-&gt;players, $this-&gt;storytellerCard, array_column($this-&gt;votes, 'cardId'));&#10;        // Erzähler wechseln&#10;        $this-&gt;storytellerIndex = ($this-&gt;storytellerIndex + 1) % count($this-&gt;players);&#10;        // Reset für neue Runde&#10;        $this-&gt;phase = 'storytelling';&#10;        $this-&gt;selectedCards = [];&#10;        $this-&gt;votes = [];&#10;        $this-&gt;hint = null;&#10;        $this-&gt;storytellerCard = null;&#10;        // Status der Kartenauswahl für alle Spieler zurücksetzen&#10;        foreach ($this-&gt;players as $player) {&#10;            $player-&gt;hasSelectedCard = false;&#10;        }&#10;    }&#10;&#10;    public function restart(): void {&#10;        foreach ($this-&gt;players as $player) {&#10;            $player-&gt;score = 0;&#10;        }&#10;        $this-&gt;phase = 'waiting';&#10;        $this-&gt;state = 'waiting';&#10;        $this-&gt;selectedCards = [];&#10;        $this-&gt;votes = [];&#10;        $this-&gt;hint = null;&#10;        $this-&gt;storytellerCard = null;&#10;        $this-&gt;winner = null;&#10;        $this-&gt;storytellerIndex = 0;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/GameManager.php">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/GameManager.php" />
              <option name="originalContent" value="&lt;?php&#10;&#10;header('Access-Control-Allow-Origin: *');&#10;header('Access-Control-Allow-Methods: POST, GET, OPTIONS');&#10;header('Access-Control-Allow-Headers: Content-Type');&#10;&#10;if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {&#10;    http_response_code(200);&#10;    exit();&#10;}&#10;&#10;&#10;require_once 'Game.php';&#10;&#10;/**&#10; * GameManager-Klasse zur Verwaltung aller laufenden Spiele&#10; */&#10;class GameManager {&#10;    /** @var Game[] */&#10;    private array $games = [];&#10;    private string $cardsFile;&#10;&#10;    /**&#10;     * Konstruktor für den GameManager&#10;     */&#10;    public function __construct(string $cardsFile = __DIR__ . '/cards.json') {&#10;        $this-&gt;cardsFile = $cardsFile;&#10;    }&#10;&#10;    /**&#10;     * Erstellt ein neues Spiel&#10;     */&#10;    public function createGame(string $playerName): array {&#10;        // Zufällige Spiel-ID generieren&#10;        $gameId = $this-&gt;generateGameId();&#10;&#10;        // Kartendaten laden&#10;        $cardData = $this-&gt;loadCardData();&#10;&#10;        // Neues Spiel erstellen&#10;        $game = new Game($gameId, $cardData);&#10;&#10;        // Spieler hinzufügen&#10;        $player = $game-&gt;addPlayer($playerName);&#10;&#10;        // Spiel in der Liste speichern&#10;        $this-&gt;games[$gameId] = $game;&#10;&#10;        return [&#10;            'success' =&gt; true,&#10;            'gameId' =&gt; $gameId,&#10;            'player' =&gt; [&#10;                'id' =&gt; $player-&gt;id,&#10;                'name' =&gt; $player-&gt;name&#10;            ]&#10;        ];&#10;    }&#10;&#10;    /**&#10;     * Lässt einen Spieler einem Spiel beitreten&#10;     */&#10;    public function joinGame(string $gameId, string $playerName): array {&#10;        if (!isset($this-&gt;games[$gameId])) {&#10;            return ['success' =&gt; false, 'message' =&gt; 'Spiel nicht gefunden'];&#10;        }&#10;&#10;        $game = $this-&gt;games[$gameId];&#10;&#10;        // Prüfen, ob der Name bereits verwendet wird&#10;        foreach ($game-&gt;players as $existingPlayer) {&#10;            if ($existingPlayer-&gt;name === $playerName) {&#10;                return ['success' =&gt; false, 'message' =&gt; 'Name bereits vergeben'];&#10;            }&#10;        }&#10;&#10;        // Spieler hinzufügen&#10;        $player = $game-&gt;addPlayer($playerName);&#10;&#10;        return [&#10;            'success' =&gt; true,&#10;            'gameId' =&gt; $gameId,&#10;            'player' =&gt; [&#10;                'id' =&gt; $player-&gt;id,&#10;                'name' =&gt; $player-&gt;name&#10;            ]&#10;        ];&#10;    }&#10;&#10;    /**&#10;     * Startet ein Spiel&#10;     */&#10;    public function startGame(string $gameId): array {&#10;        if (!isset($this-&gt;games[$gameId])) {&#10;            return ['success' =&gt; false, 'message' =&gt; 'Spiel nicht gefunden'];&#10;        }&#10;&#10;        $game = $this-&gt;games[$gameId];&#10;&#10;        if (count($game-&gt;players) &lt; 3) {&#10;            return ['success' =&gt; false, 'message' =&gt; 'Mindestens 3 Spieler benötigt'];&#10;        }&#10;&#10;        $game-&gt;startRound();&#10;&#10;        return ['success' =&gt; true];&#10;    }&#10;&#10;    /**&#10;     * Gibt den aktuellen Spielstatus zurück&#10;     */&#10;    public function getGameState(string $gameId, string $playerName = null): array {&#10;        if (!isset($this-&gt;games[$gameId])) {&#10;            return ['success' =&gt; false, 'message' =&gt; 'Spiel nicht gefunden'];&#10;        }&#10;&#10;        $game = $this-&gt;games[$gameId];&#10;        return array_merge(['success' =&gt; true], $game-&gt;getState($playerName));&#10;    }&#10;&#10;    /**&#10;     * Erzähler gibt einen Hinweis&#10;     */&#10;    public function giveHint(string $gameId, string $playerName, string $cardId, string $hint): array {&#10;        if (!isset($this-&gt;games[$gameId])) {&#10;            return ['success' =&gt; false, 'message' =&gt; 'Spiel nicht gefunden'];&#10;        }&#10;&#10;        $game = $this-&gt;games[$gameId];&#10;        $result = $game-&gt;giveHint($playerName, $cardId, $hint);&#10;&#10;        return ['success' =&gt; $result];&#10;    }&#10;&#10;    /**&#10;     * Spieler wählt eine Karte aus&#10;     */&#10;    public function chooseCard(string $gameId, string $playerName, string $cardId): array {&#10;        if (!isset($this-&gt;games[$gameId])) {&#10;            return ['success' =&gt; false, 'message' =&gt; 'Spiel nicht gefunden'];&#10;        }&#10;&#10;        $game = $this-&gt;games[$gameId];&#10;        $result = $game-&gt;chooseCard($playerName, $cardId);&#10;&#10;        return ['success' =&gt; $result];&#10;    }&#10;&#10;    /**&#10;     * Spieler stimmt für eine Karte ab&#10;     */&#10;    public function vote(string $gameId, string $playerName, string $cardId): array {&#10;        if (!isset($this-&gt;games[$gameId])) {&#10;            return ['success' =&gt; false, 'message' =&gt; 'Spiel nicht gefunden'];&#10;        }&#10;&#10;        $game = $this-&gt;games[$gameId];&#10;        $result = $game-&gt;vote($playerName, $cardId);&#10;&#10;        return ['success' =&gt; $result];&#10;    }&#10;&#10;    /**&#10;     * Wechselt zur nächsten Runde&#10;     */&#10;    public function nextRound(string $gameId): array {&#10;        if (!isset($this-&gt;games[$gameId])) {&#10;            return ['success' =&gt; false, 'message' =&gt; 'Spiel nicht gefunden'];&#10;        }&#10;&#10;        $game = $this-&gt;games[$gameId];&#10;        $game-&gt;nextRound();&#10;&#10;        return ['success' =&gt; true];&#10;    }&#10;&#10;    /**&#10;     * Generiert eine zufällige Spiel-ID&#10;     */&#10;    private function generateGameId(int $length = 6): string {&#10;        $characters = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';&#10;        $id = '';&#10;&#10;        do {&#10;            $id = '';&#10;            for ($i = 0; $i &lt; $length; $i++) {&#10;                $id .= $characters[rand(0, strlen($characters) - 1)];&#10;            }&#10;        } while (isset($this-&gt;games[$id]));&#10;&#10;        return $id;&#10;    }&#10;&#10;    /**&#10;     * Lädt die Kartendaten aus der JSON-Datei&#10;     */&#10;    private function loadCardData(): array {&#10;        if (!file_exists($this-&gt;cardsFile)) {&#10;            // Fallback: Leere Liste zurückgeben oder Beispielkarten&#10;            return [&#10;                ['id' =&gt; '1', 'title' =&gt; 'Karte 1', 'image' =&gt; 'card1.jpg'],&#10;                ['id' =&gt; '2', 'title' =&gt; 'Karte 2', 'image' =&gt; 'card2.jpg'],&#10;                ['id' =&gt; '3', 'title' =&gt; 'Karte 3', 'image' =&gt; 'card3.jpg']&#10;            ];&#10;        }&#10;&#10;        $jsonData = file_get_contents($this-&gt;cardsFile);&#10;        return json_decode($jsonData, true) ?: [];&#10;    }&#10;}&#10;?&gt;&#10;" />
              <option name="updatedContent" value="&lt;?php&#10;&#10;header('Access-Control-Allow-Origin: *');&#10;header('Access-Control-Allow-Methods: POST, GET, OPTIONS');&#10;header('Access-Control-Allow-Headers: Content-Type');&#10;&#10;if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {&#10;    http_response_code(200);&#10;    exit();&#10;}&#10;&#10;require_once 'Game.php';&#10;require_once 'Database.php';&#10;&#10;/**&#10; * GameManager-Klasse zur Verwaltung aller laufenden Spiele&#10; */&#10;class GameManager {&#10;    /** @var Game[] */&#10;    private array $games = [];&#10;    private string $cardsFile;&#10;    private PDO $db;&#10;&#10;    /**&#10;     * Konstruktor für den GameManager&#10;     */&#10;    public function __construct(string $cardsFile = __DIR__ . '/cards.json') {&#10;        $this-&gt;cardsFile = $cardsFile;&#10;        $this-&gt;db = Database::getConnection();&#10;        $this-&gt;loadGamesFromDatabase();&#10;    }&#10;&#10;    /**&#10;     * Erstellt ein neues Spiel&#10;     */&#10;    public function createGame(string $playerName): array {&#10;        // Zufällige Spiel-ID generieren&#10;        $gameId = $this-&gt;generateGameId();&#10;&#10;        // Kartendaten laden&#10;        $cardData = $this-&gt;loadCardData();&#10;&#10;        // Neues Spiel erstellen&#10;        $game = new Game($gameId, $cardData);&#10;&#10;        // Spieler hinzufügen&#10;        $player = $game-&gt;addPlayer($playerName);&#10;&#10;        // Spiel in der Liste speichern&#10;        $this-&gt;games[$gameId] = $game;&#10;        &#10;        // In Datenbank speichern&#10;        $this-&gt;saveGameToDatabase($game);&#10;&#10;        return [&#10;            'success' =&gt; true,&#10;            'gameId' =&gt; $gameId,&#10;            'player' =&gt; [&#10;                'id' =&gt; $player-&gt;id,&#10;                'name' =&gt; $player-&gt;name&#10;            ]&#10;        ];&#10;    }&#10;&#10;    /**&#10;     * Lässt einen Spieler einem Spiel beitreten&#10;     */&#10;    public function joinGame(string $gameId, string $playerName): array {&#10;        // Spiel aus Datenbank laden falls nicht im Speicher&#10;        if (!isset($this-&gt;games[$gameId])) {&#10;            $this-&gt;loadGameFromDatabase($gameId);&#10;        }&#10;        &#10;        if (!isset($this-&gt;games[$gameId])) {&#10;            return ['success' =&gt; false, 'message' =&gt; 'Spiel nicht gefunden'];&#10;        }&#10;&#10;        $game = $this-&gt;games[$gameId];&#10;&#10;        // Prüfen, ob der Name bereits verwendet wird&#10;        foreach ($game-&gt;players as $existingPlayer) {&#10;            if ($existingPlayer-&gt;name === $playerName) {&#10;                return ['success' =&gt; false, 'message' =&gt; 'Name bereits vergeben'];&#10;            }&#10;        }&#10;&#10;        // Spieler hinzufügen&#10;        $player = $game-&gt;addPlayer($playerName);&#10;        &#10;        // In Datenbank speichern&#10;        $this-&gt;saveGameToDatabase($game);&#10;&#10;        return [&#10;            'success' =&gt; true,&#10;            'gameId' =&gt; $gameId,&#10;            'player' =&gt; [&#10;                'id' =&gt; $player-&gt;id,&#10;                'name' =&gt; $player-&gt;name&#10;            ]&#10;        ];&#10;    }&#10;&#10;    /**&#10;     * Startet ein Spiel&#10;     */&#10;    public function startGame(string $gameId): array {&#10;        if (!isset($this-&gt;games[$gameId])) {&#10;            $this-&gt;loadGameFromDatabase($gameId);&#10;        }&#10;        &#10;        if (!isset($this-&gt;games[$gameId])) {&#10;            return ['success' =&gt; false, 'message' =&gt; 'Spiel nicht gefunden'];&#10;        }&#10;&#10;        $game = $this-&gt;games[$gameId];&#10;&#10;        if (count($game-&gt;players) &lt; 3) {&#10;            return ['success' =&gt; false, 'message' =&gt; 'Mindestens 3 Spieler benötigt'];&#10;        }&#10;&#10;        $game-&gt;startRound();&#10;        $this-&gt;saveGameToDatabase($game);&#10;&#10;        return ['success' =&gt; true];&#10;    }&#10;&#10;    /**&#10;     * Gibt den aktuellen Spielstatus zurück&#10;     */&#10;    public function getGameState(string $gameId, string $playerName = null): array {&#10;        if (!isset($this-&gt;games[$gameId])) {&#10;            $this-&gt;loadGameFromDatabase($gameId);&#10;        }&#10;        &#10;        if (!isset($this-&gt;games[$gameId])) {&#10;            return ['success' =&gt; false, 'message' =&gt; 'Spiel nicht gefunden'];&#10;        }&#10;&#10;        $game = $this-&gt;games[$gameId];&#10;        return array_merge(['success' =&gt; true], $game-&gt;getState($playerName));&#10;    }&#10;&#10;    /**&#10;     * Erzähler gibt einen Hinweis&#10;     */&#10;    public function giveHint(string $gameId, string $playerName, string $cardId, string $hint): array {&#10;        if (!isset($this-&gt;games[$gameId])) {&#10;            $this-&gt;loadGameFromDatabase($gameId);&#10;        }&#10;        &#10;        if (!isset($this-&gt;games[$gameId])) {&#10;            return ['success' =&gt; false, 'message' =&gt; 'Spiel nicht gefunden'];&#10;        }&#10;&#10;        $game = $this-&gt;games[$gameId];&#10;        $result = $game-&gt;giveHint($playerName, $cardId, $hint);&#10;        &#10;        if ($result) {&#10;            $this-&gt;saveGameToDatabase($game);&#10;        }&#10;&#10;        return ['success' =&gt; $result];&#10;    }&#10;&#10;    /**&#10;     * Spieler wählt eine Karte aus&#10;     */&#10;    public function chooseCard(string $gameId, string $playerName, string $cardId): array {&#10;        if (!isset($this-&gt;games[$gameId])) {&#10;            $this-&gt;loadGameFromDatabase($gameId);&#10;        }&#10;        &#10;        if (!isset($this-&gt;games[$gameId])) {&#10;            return ['success' =&gt; false, 'message' =&gt; 'Spiel nicht gefunden'];&#10;        }&#10;&#10;        $game = $this-&gt;games[$gameId];&#10;        $result = $game-&gt;chooseCard($playerName, $cardId);&#10;        &#10;        if ($result) {&#10;            $this-&gt;saveGameToDatabase($game);&#10;        }&#10;&#10;        return ['success' =&gt; $result];&#10;    }&#10;&#10;    /**&#10;     * Spieler stimmt für eine Karte ab&#10;     */&#10;    public function vote(string $gameId, string $playerName, string $cardId): array {&#10;        if (!isset($this-&gt;games[$gameId])) {&#10;            $this-&gt;loadGameFromDatabase($gameId);&#10;        }&#10;        &#10;        if (!isset($this-&gt;games[$gameId])) {&#10;            return ['success' =&gt; false, 'message' =&gt; 'Spiel nicht gefunden'];&#10;        }&#10;&#10;        $game = $this-&gt;games[$gameId];&#10;        $result = $game-&gt;vote($playerName, $cardId);&#10;        &#10;        if ($result) {&#10;            $this-&gt;saveGameToDatabase($game);&#10;        }&#10;&#10;        return ['success' =&gt; $result];&#10;    }&#10;&#10;    /**&#10;     * Wechselt zur nächsten Runde&#10;     */&#10;    public function nextRound(string $gameId): array {&#10;        if (!isset($this-&gt;games[$gameId])) {&#10;            $this-&gt;loadGameFromDatabase($gameId);&#10;        }&#10;        &#10;        if (!isset($this-&gt;games[$gameId])) {&#10;            return ['success' =&gt; false, 'message' =&gt; 'Spiel nicht gefunden'];&#10;        }&#10;&#10;        $game = $this-&gt;games[$gameId];&#10;        $game-&gt;nextRound();&#10;        $this-&gt;saveGameToDatabase($game);&#10;&#10;        return ['success' =&gt; true];&#10;    }&#10;&#10;    /**&#10;     * Speichert ein Spiel in der Datenbank&#10;     */&#10;    private function saveGameToDatabase(Game $game): void {&#10;        try {&#10;            // Game State serialisieren&#10;            $gameState = [&#10;                'gameId' =&gt; $game-&gt;gameId,&#10;                'storytellerIndex' =&gt; $game-&gt;storytellerIndex,&#10;                'phase' =&gt; $game-&gt;phase,&#10;                'selectedCards' =&gt; $game-&gt;selectedCards,&#10;                'votes' =&gt; $game-&gt;votes,&#10;                'hint' =&gt; $game-&gt;hint,&#10;                'storytellerCard' =&gt; $game-&gt;storytellerCard,&#10;                'winner' =&gt; $game-&gt;winner,&#10;                'mixedCards' =&gt; $game-&gt;mixedCards,&#10;                'state' =&gt; $game-&gt;state,&#10;                'cardData' =&gt; $game-&gt;cardData&#10;            ];&#10;&#10;            // Spiel in games Tabelle speichern/aktualisieren&#10;            $stmt = $this-&gt;db-&gt;prepare(&quot;&#10;                INSERT INTO games (id, state) VALUES (?, ?)&#10;                ON DUPLICATE KEY UPDATE state = VALUES(state), updated_at = CURRENT_TIMESTAMP&#10;            &quot;);&#10;            $stmt-&gt;execute([$game-&gt;gameId, json_encode($gameState)]);&#10;&#10;            // Spieler speichern&#10;            foreach ($game-&gt;players as $player) {&#10;                $stmt = $this-&gt;db-&gt;prepare(&quot;&#10;                    INSERT INTO players (game_id, player_id, name, cards, score) VALUES (?, ?, ?, ?, ?)&#10;                    ON DUPLICATE KEY UPDATE name = VALUES(name), cards = VALUES(cards), score = VALUES(score)&#10;                &quot;);&#10;                $stmt-&gt;execute([&#10;                    $game-&gt;gameId,&#10;                    $player-&gt;id,&#10;                    $player-&gt;name,&#10;                    json_encode($player-&gt;cards),&#10;                    $player-&gt;score&#10;                ]);&#10;            }&#10;        } catch (PDOException $e) {&#10;            error_log(&quot;Fehler beim Speichern des Spiels: &quot; . $e-&gt;getMessage());&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Lädt ein Spiel aus der Datenbank&#10;     */&#10;    private function loadGameFromDatabase(string $gameId): void {&#10;        try {&#10;            // Spiel laden&#10;            $stmt = $this-&gt;db-&gt;prepare(&quot;SELECT state FROM games WHERE id = ?&quot;);&#10;            $stmt-&gt;execute([$gameId]);&#10;            $gameData = $stmt-&gt;fetch();&#10;&#10;            if (!$gameData) {&#10;                return;&#10;            }&#10;&#10;            $state = json_decode($gameData['state'], true);&#10;            &#10;            // Game-Objekt erstellen&#10;            $game = new Game($gameId, $state['cardData'] ?? []);&#10;            $game-&gt;storytellerIndex = $state['storytellerIndex'] ?? 0;&#10;            $game-&gt;phase = $state['phase'] ?? 'waiting';&#10;            $game-&gt;selectedCards = $state['selectedCards'] ?? [];&#10;            $game-&gt;votes = $state['votes'] ?? [];&#10;            $game-&gt;hint = $state['hint'] ?? null;&#10;            $game-&gt;storytellerCard = $state['storytellerCard'] ?? null;&#10;            $game-&gt;winner = $state['winner'] ?? null;&#10;            $game-&gt;mixedCards = $state['mixedCards'] ?? [];&#10;            $game-&gt;state = $state['state'] ?? 'waiting';&#10;&#10;            // Spieler laden&#10;            $stmt = $this-&gt;db-&gt;prepare(&quot;SELECT player_id, name, cards, score FROM players WHERE game_id = ? ORDER BY player_id&quot;);&#10;            $stmt-&gt;execute([$gameId]);&#10;            $playersData = $stmt-&gt;fetchAll();&#10;&#10;            foreach ($playersData as $playerData) {&#10;                $player = new Player($playerData['player_id'], $playerData['name']);&#10;                $player-&gt;cards = json_decode($playerData['cards'], true) ?? [];&#10;                $player-&gt;score = $playerData['score'];&#10;                $game-&gt;players[] = $player;&#10;            }&#10;&#10;            $this-&gt;games[$gameId] = $game;&#10;        } catch (PDOException $e) {&#10;            error_log(&quot;Fehler beim Laden des Spiels: &quot; . $e-&gt;getMessage());&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Lädt alle Spiele aus der Datenbank&#10;     */&#10;    private function loadGamesFromDatabase(): void {&#10;        try {&#10;            $stmt = $this-&gt;db-&gt;prepare(&quot;SELECT id FROM games WHERE updated_at &gt; DATE_SUB(NOW(), INTERVAL 24 HOUR)&quot;);&#10;            $stmt-&gt;execute();&#10;            $gameIds = $stmt-&gt;fetchAll(PDO::FETCH_COLUMN);&#10;&#10;            foreach ($gameIds as $gameId) {&#10;                $this-&gt;loadGameFromDatabase($gameId);&#10;            }&#10;        } catch (PDOException $e) {&#10;            error_log(&quot;Fehler beim Laden der Spiele: &quot; . $e-&gt;getMessage());&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Generiert eine zufällige Spiel-ID&#10;     */&#10;    private function generateGameId(int $length = 6): string {&#10;        $characters = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';&#10;        $id = '';&#10;&#10;        do {&#10;            $id = '';&#10;            for ($i = 0; $i &lt; $length; $i++) {&#10;                $id .= $characters[rand(0, strlen($characters) - 1)];&#10;            }&#10;        } while (isset($this-&gt;games[$id]));&#10;&#10;        return $id;&#10;    }&#10;&#10;    /**&#10;     * Lädt die Kartendaten aus der JSON-Datei&#10;     */&#10;    private function loadCardData(): array {&#10;        if (!file_exists($this-&gt;cardsFile)) {&#10;            // Fallback: Leere Liste zurückgeben oder Beispielkarten&#10;            return [&#10;                ['id' =&gt; '1', 'title' =&gt; 'Karte 1', 'image' =&gt; 'card1.jpg'],&#10;                ['id' =&gt; '2', 'title' =&gt; 'Karte 2', 'image' =&gt; 'card2.jpg'],&#10;                ['id' =&gt; '3', 'title' =&gt; 'Karte 3', 'image' =&gt; 'card3.jpg']&#10;            ];&#10;        }&#10;&#10;        $jsonData = file_get_contents($this-&gt;cardsFile);&#10;        return json_decode($jsonData, true) ?: [];&#10;    }&#10;}&#10;?&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/Lobby.php">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/Lobby.php" />
              <option name="originalContent" value="&lt;?php&#10;// CORS-Header für alle Anfragen setzen&#10;header('Access-Control-Allow-Origin: *');&#10;header('Access-Control-Allow-Methods: POST, GET, OPTIONS');&#10;header('Access-Control-Allow-Headers: Content-Type, Authorization');&#10;header('Content-Type: application/json');&#10;&#10;// Sicherstellen, dass keine weiteren CORS-Header gesetzt werden&#10;if (function_exists('apache_response_headers')) {&#10;    $headers = apache_response_headers();&#10;    if (isset($headers['Access-Control-Allow-Origin']) &amp;&amp; strpos($headers['Access-Control-Allow-Origin'], ',') !== false) {&#10;        header_remove('Access-Control-Allow-Origin');&#10;        header('Access-Control-Allow-Origin: *');&#10;    }&#10;}&#10;&#10;// OPTIONS-Preflight-Anfragen behandeln&#10;if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {&#10;    http_response_code(200);&#10;    exit();&#10;}&#10;&#10;// Error Reporting für Debugging&#10;error_reporting(E_ALL);&#10;ini_set('display_errors', 1);&#10;&#10;try {&#10;    // Prüfen ob Dateien existieren&#10;    if (!file_exists('Player.php')) {&#10;        throw new Exception('Player.php nicht gefunden');&#10;    }&#10;    if (!file_exists('GameManager.php')) {&#10;        throw new Exception('GameManager.php nicht gefunden');&#10;    }&#10;&#10;    require_once 'Player.php';&#10;    require_once 'GameManager.php';&#10;&#10;    // Prüfen ob Klasse existiert&#10;    if (!class_exists('GameManager')) {&#10;        throw new Exception('GameManager-Klasse nicht gefunden');&#10;    }&#10;&#10;    $gameManager = new GameManager();&#10;&#10;    if ($_SERVER['REQUEST_METHOD'] === 'POST') {&#10;        $jsonData = file_get_contents('php://input');&#10;&#10;        if ($jsonData === false) {&#10;            throw new Exception('Konnte Request-Body nicht lesen');&#10;        }&#10;&#10;        $data = json_decode($jsonData, true);&#10;&#10;        if (json_last_error() !== JSON_ERROR_NONE) {&#10;            throw new Exception('JSON-Parsing-Fehler: ' . json_last_error_msg());&#10;        }&#10;&#10;        if (!$data) {&#10;            throw new Exception('Keine JSON-Daten empfangen');&#10;        }&#10;&#10;        if (!isset($data['playerName'])) {&#10;            throw new Exception('Spielername fehlt in den Daten');&#10;        }&#10;&#10;        $playerName = $data['playerName'];&#10;&#10;        if (isset($data['gameId'])) {&#10;            // Spiel beitreten&#10;            $gameId = $data['gameId'];&#10;            $result = $gameManager-&gt;joinGame($gameId, $playerName);&#10;        } else {&#10;            // Neues Spiel erstellen&#10;            $result = $gameManager-&gt;createGame($playerName);&#10;        }&#10;&#10;        echo json_encode($result);&#10;    } else {&#10;        echo json_encode(['success' =&gt; false, 'message' =&gt; 'Nur POST-Anfragen unterstützt']);&#10;    }&#10;&#10;} catch (Error $e) {&#10;    error_log('PHP Error in Lobby.php: ' . $e-&gt;getMessage());&#10;    echo json_encode(['success' =&gt; false, 'message' =&gt; 'PHP-Fehler: ' . $e-&gt;getMessage()]);&#10;} catch (Exception $e) {&#10;    error_log('Exception in Lobby.php: ' . $e-&gt;getMessage());&#10;    echo json_encode(['success' =&gt; false, 'message' =&gt; 'Server-Fehler: ' . $e-&gt;getMessage()]);&#10;} catch (Throwable $e) {&#10;    error_log('Throwable in Lobby.php: ' . $e-&gt;getMessage());&#10;    echo json_encode(['success' =&gt; false, 'message' =&gt; 'Unerwarteter Fehler: ' . $e-&gt;getMessage()]);&#10;}&#10;?&gt;&#10;" />
              <option name="updatedContent" value="&lt;?php&#10;// CORS-Header für alle Anfragen setzen&#10;header('Access-Control-Allow-Origin: *');&#10;header('Access-Control-Allow-Methods: POST, GET, OPTIONS');&#10;header('Access-Control-Allow-Headers: Content-Type, Authorization');&#10;header('Content-Type: application/json');&#10;&#10;// Sicherstellen, dass keine weiteren CORS-Header gesetzt werden&#10;if (function_exists('apache_response_headers')) {&#10;    $headers = apache_response_headers();&#10;    if (isset($headers['Access-Control-Allow-Origin']) &amp;&amp; strpos($headers['Access-Control-Allow-Origin'], ',') !== false) {&#10;        header_remove('Access-Control-Allow-Origin');&#10;        header('Access-Control-Allow-Origin: *');&#10;    }&#10;}&#10;&#10;// OPTIONS-Preflight-Anfragen behandeln&#10;if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {&#10;    http_response_code(200);&#10;    exit();&#10;}&#10;&#10;// Error Reporting für Debugging&#10;error_reporting(E_ALL);&#10;ini_set('display_errors', 1);&#10;&#10;try {&#10;    // Prüfen ob Dateien existieren&#10;    if (!file_exists('Player.php')) {&#10;        throw new Exception('Player.php nicht gefunden');&#10;    }&#10;    if (!file_exists('GameManager.php')) {&#10;        throw new Exception('GameManager.php nicht gefunden');&#10;    }&#10;&#10;    require_once 'Player.php';&#10;    require_once 'GameManager.php';&#10;&#10;    // Prüfen ob Klasse existiert&#10;    if (!class_exists('GameManager')) {&#10;        throw new Exception('GameManager-Klasse nicht gefunden');&#10;    }&#10;&#10;    $gameManager = new GameManager();&#10;&#10;    if ($_SERVER['REQUEST_METHOD'] === 'POST') {&#10;        $jsonData = file_get_contents('php://input');&#10;&#10;        if ($jsonData === false) {&#10;            throw new Exception('Konnte Request-Body nicht lesen');&#10;        }&#10;&#10;        $data = json_decode($jsonData, true);&#10;&#10;        if (json_last_error() !== JSON_ERROR_NONE) {&#10;            throw new Exception('JSON-Parsing-Fehler: ' . json_last_error_msg());&#10;        }&#10;&#10;        if (!$data) {&#10;            throw new Exception('Keine JSON-Daten empfangen');&#10;        }&#10;&#10;        if (!isset($data['playerName'])) {&#10;            throw new Exception('Spielername fehlt in den Daten');&#10;        }&#10;&#10;        $playerName = $data['playerName'];&#10;&#10;        if (isset($data['gameId'])) {&#10;            // Spiel beitreten&#10;            $gameId = $data['gameId'];&#10;            $result = $gameManager-&gt;joinGame($gameId, $playerName);&#10;        } else {&#10;            // Neues Spiel erstellen&#10;            $result = $gameManager-&gt;createGame($playerName);&#10;        }&#10;&#10;        echo json_encode($result);&#10;    } else {&#10;        echo json_encode(['success' =&gt; false, 'message' =&gt; 'Nur POST-Anfragen unterstützt']);&#10;    }&#10;&#10;} catch (Error $e) {&#10;    error_log('PHP Error in Lobby.php: ' . $e-&gt;getMessage());&#10;    echo json_encode(['success' =&gt; false, 'message' =&gt; 'PHP-Fehler: ' . $e-&gt;getMessage()]);&#10;} catch (Exception $e) {&#10;    error_log('Exception in Lobby.php: ' . $e-&gt;getMessage());&#10;    echo json_encode(['success' =&gt; false, 'message' =&gt; 'Server-Fehler: ' . $e-&gt;getMessage()]);&#10;} catch (Throwable $e) {&#10;    error_log('Throwable in Lobby.php: ' . $e-&gt;getMessage());&#10;    echo json_encode(['success' =&gt; false, 'message' =&gt; 'Unerwarteter Fehler: ' . $e-&gt;getMessage()]);&#10;}&#10;?&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/config.php">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/config.php" />
              <option name="updatedContent" value="&lt;?php&#10;// Datenbankverbindung Konfiguration&#10;return [&#10;    'DB_HOST' =&gt; 'dein-db-host.netcup.net',&#10;    'DB_NAME' =&gt; 'datenbankname',&#10;    'DB_USER' =&gt; 'benutzername',&#10;    'DB_PASS' =&gt; 'passwort',&#10;    'DB_CHARSET' =&gt; 'utf8mb4'&#10;];&#10;?&gt;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/config/database.php">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/config/database.php" />
              <option name="updatedContent" value="&lt;?php&#10;// Datenbankverbindung Konfiguration - NIEMALS in Webverzeichnis!&#10;return [&#10;    'DB_HOST' =&gt; 'dein-db-host.netcup.net',&#10;    'DB_NAME' =&gt; 'datenbankname', &#10;    'DB_USER' =&gt; 'benutzername',&#10;    'DB_PASS' =&gt; 'passwort',&#10;    'DB_CHARSET' =&gt; 'utf8mb4'&#10;];&#10;?&gt;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/.htaccess">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/.htaccess" />
              <option name="originalContent" value="# React SPA Routing&#10;RewriteEngine On&#10;RewriteBase /frontend/&#10;RewriteCond %{REQUEST_FILENAME} !-f&#10;RewriteCond %{REQUEST_FILENAME} !-d&#10;RewriteRule ^ index.html [L]&#10;&#10;&#10;" />
              <option name="updatedContent" value="# React SPA Routing&#13;&#10;RewriteEngine On&#13;&#10;RewriteBase /frontend/&#13;&#10;RewriteCond %{REQUEST_FILENAME} !-f&#13;&#10;RewriteCond %{REQUEST_FILENAME} !-d&#13;&#10;RewriteRule ^ index.html [L]" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/src/App.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/src/App.js" />
              <option name="originalContent" value="import React, { useState, useEffect } from 'react';&#10;import { createGame, joinGame, getGameState } from './api';&#10;import Lobby from './Lobby';&#10;import Game from './Game';&#10;import VolumeControl from './components/VolumeControl';&#10;import audioManager from './AudioManager';&#10;&#10;class ErrorBoundary extends React.Component {&#10;    constructor(props) {&#10;        super(props);&#10;        this.state = { hasError: false, error: null };&#10;    }&#10;    static getDerivedStateFromError(error) {&#10;        return { hasError: true, error };&#10;    }&#10;    componentDidCatch(error, errorInfo) {&#10;        console.error('ErrorBoundary caught:', error, errorInfo);&#10;    }&#10;    render() {&#10;        if (this.state.hasError) {&#10;            return (&#10;                &lt;div style={{ color: 'red', padding: '40px', background: '#fff' }}&gt;&#10;                    &lt;h2&gt;Ein Fehler ist aufgetreten!&lt;/h2&gt;&#10;                    &lt;pre&gt;{this.state.error &amp;&amp; this.state.error.toString()}&lt;/pre&gt;&#10;                &lt;/div&gt;&#10;            );&#10;        }&#10;        return this.props.children;&#10;    }&#10;}&#10;&#10;function App() {&#10;    const [gameId, setGameId] = useState('');&#10;    const [playerName, setPlayerName] = useState('');&#10;    const [isInGame, setIsInGame] = useState(false);&#10;    const [players, setPlayers] = useState([]);&#10;    const [error, setError] = useState('');&#10;    const [volume, setVolume] = useState(0.3); // Reduzierte Standard-Lautstärke&#10;&#10;    // Initialisiere AudioManager beim App-Start&#10;    useEffect(() =&gt; {&#10;        audioManager.setVolume(volume);&#10;&#10;        // Auto-start Lobby-Musik mit reduzierter Lautstärke&#10;        audioManager.playTrack('lobby.mp3', true, 2000);&#10;&#10;        // Cleanup bei App-Beendigung&#10;        return () =&gt; {&#10;            audioManager.stopTrack(500);&#10;        };&#10;    }, []);&#10;&#10;    // Volume änderungen an AudioManager weiterleiten&#10;    useEffect(() =&gt; {&#10;        audioManager.setVolume(volume);&#10;    }, [volume]);&#10;&#10;    useEffect(() =&gt; {&#10;        if (gameId) {&#10;            getGameState(gameId).then(state =&gt; {&#10;                if (state.success) {&#10;                    setPlayers(state.players || []);&#10;                }&#10;            }).catch(err =&gt; {&#10;                console.error(&quot;Fehler beim Abrufen des Spielstatus:&quot;, err);&#10;            });&#10;        }&#10;    }, [gameId, isInGame]);&#10;&#10;    const handleJoin = async (roomId, name) =&gt; {&#10;        if (!roomId || !name) {&#10;            setError('Bitte Raum-ID und Namen eingeben!');&#10;            return;&#10;        }&#10;        try {&#10;            const res = await joinGame(roomId, name);&#10;            if (res.success) {&#10;                setGameId(roomId);&#10;                setPlayerName(name);&#10;                setIsInGame(true);&#10;                setError('');&#10;            } else {&#10;                setError(res.message || 'Beitritt fehlgeschlagen');&#10;            }&#10;        } catch (e) {&#10;            setError('Serverfehler');&#10;            console.error(e);&#10;        }&#10;    };&#10;&#10;    const handleStart = async (name) =&gt; {&#10;        if (!name) {&#10;            setError('Bitte Namen eingeben!');&#10;            return;&#10;        }&#10;        try {&#10;            const res = await createGame(name);&#10;            if (res.success) {&#10;                setGameId(res.gameId);&#10;                setPlayerName(name);&#10;                setIsInGame(true);&#10;                setError('');&#10;            } else {&#10;                setError(res.message || 'Start fehlgeschlagen');&#10;            }&#10;        } catch (e) {&#10;            setError('Serverfehler');&#10;            console.error(e);&#10;        }&#10;    };&#10;&#10;    const handleLeaveGame = () =&gt; {&#10;        setIsInGame(false);&#10;        setGameId('');&#10;        setPlayers([]);&#10;        // Wechsel zurück zur Lobby-Musik&#10;        audioManager.playTrack('lobby.mp3', true, 1000);&#10;    };&#10;&#10;    const handleVolumeChange = (newVolume) =&gt; {&#10;        setVolume(newVolume);&#10;    };&#10;&#10;    return (&#10;        &lt;ErrorBoundary&gt;&#10;            &lt;div className=&quot;App&quot;&gt;&#10;                {/* VolumeControl immer sichtbar machen */}&#10;                &lt;VolumeControl volume={volume} onChange={handleVolumeChange} /&gt;&#10;&#10;                &lt;div style={{&#10;                    minHeight: '100vh',&#10;                    background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',&#10;                    padding: '20px'&#10;                }}&gt;&#10;                    &lt;div style={{ maxWidth: '800px', margin: '0 auto' }}&gt;&#10;                        {/* App Header */}&#10;                        &lt;div style={{&#10;                            textAlign: 'center',&#10;                            marginBottom: '40px',&#10;                            background: 'rgba(255,255,255,0.1)',&#10;                            padding: '30px',&#10;                            borderRadius: '20px',&#10;                            backdropFilter: 'blur(10px)',&#10;                            color: 'white',&#10;                            boxShadow: '0 8px 32px rgba(0,0,0,0.1)',&#10;                            position: 'relative'&#10;                        }}&gt;&#10;                            &lt;h1 style={{&#10;                                margin: '0 0 15px 0',&#10;                                fontSize: '42px',&#10;                                fontWeight: 'bold',&#10;                                textShadow: '3px 3px 6px rgba(0,0,0,0.3)',&#10;                                background: 'linear-gradient(45deg, #ffd700, #ffed4e)',&#10;                                WebkitBackgroundClip: 'text',&#10;                                WebkitTextFillColor: 'transparent',&#10;                                backgroundClip: 'text'&#10;                            }}&gt;&#10;                                 Don't Choose Me&#10;                            &lt;/h1&gt;&#10;                            &lt;p style={{&#10;                                margin: 0,&#10;                                fontSize: '18px',&#10;                                opacity: 0.9,&#10;                                fontWeight: '300'&#10;                            }}&gt;&#10;                                Das kreative Ratespiel für Freunde und Familie&#10;                            &lt;/p&gt;&#10;&#10;                            {/* Audio Indicator für Startseite */}&#10;                            {!isInGame &amp;&amp; (&#10;                                &lt;div style={{&#10;                                    position: 'absolute',&#10;                                    top: '15px',&#10;                                    right: '15px',&#10;                                    display: 'flex',&#10;                                    alignItems: 'center',&#10;                                    gap: '8px',&#10;                                    background: 'rgba(255,255,255,0.1)',&#10;                                    padding: '6px 12px',&#10;                                    borderRadius: '20px',&#10;                                    fontSize: '12px',&#10;                                    opacity: 0.7&#10;                                }}&gt;&#10;                                     Willkommensmusik&#10;                                &lt;/div&gt;&#10;                            )}&#10;                        &lt;/div&gt;&#10;&#10;                        {/* Main Content */}&#10;                        &lt;div style={{&#10;                            background: 'rgba(255,255,255,0.1)',&#10;                            borderRadius: '20px',&#10;                            padding: '30px',&#10;                            backdropFilter: 'blur(10px)',&#10;                            boxShadow: '0 8px 32px rgba(0,0,0,0.1)',&#10;                            border: '1px solid rgba(255,255,255,0.2)'&#10;                        }}&gt;&#10;                            {isInGame ? (&#10;                                &lt;Game&#10;                                    gameId={gameId}&#10;                                    playerName={playerName}&#10;                                    onLeaveGame={handleLeaveGame}&#10;                                    volume={volume}&#10;                                    setVolume={setVolume}&#10;                                /&gt;&#10;                            ) : (&#10;                                &lt;Lobby&#10;                                    players={players}&#10;                                    gameId={gameId}&#10;                                    error={error}&#10;                                    onJoin={handleJoin}&#10;                                    onStart={handleStart}&#10;                                    onLeave={handleLeaveGame}&#10;                                /&gt;&#10;                            )}&#10;                        &lt;/div&gt;&#10;&#10;                        {/* Footer */}&#10;                        &lt;div style={{&#10;                            textAlign: 'center',&#10;                            marginTop: '30px',&#10;                            color: 'rgba(255,255,255,0.7)',&#10;                            fontSize: '14px'&#10;                        }}&gt;&#10;                            &lt;p style={{ margin: 0 }}&gt;&#10;                                 Ein Erzähler gibt einen Hinweis zu seiner Karte&lt;br/&gt;&#10;                                 Andere wählen passende Karten aus ihrer Hand&lt;br/&gt;&#10;                                ️ Alle raten, welche Karte vom Erzähler stammt&lt;br/&gt;&#10;                                 Erste Person mit 30 Punkten gewinnt!&#10;                            &lt;/p&gt;&#10;                        &lt;/div&gt;&#10;                    &lt;/div&gt;&#10;                &lt;/div&gt;&#10;            &lt;/div&gt;&#10;        &lt;/ErrorBoundary&gt;&#10;    );&#10;}&#10;&#10;export default App;&#10;" />
              <option name="updatedContent" value="import React, { useState, useEffect } from 'react';&#10;import { createGame, joinGame, getGameState } from './api';&#10;import Lobby from './Lobby';&#10;import Game from './Game';&#10;import VolumeControl from './components/VolumeControl';&#10;import audioManager from './AudioManager';&#10;&#10;class ErrorBoundary extends React.Component {&#10;    constructor(props) {&#10;        super(props);&#10;        this.state = { hasError: false, error: null };&#10;    }&#10;    static getDerivedStateFromError(error) {&#10;        return { hasError: true, error };&#10;    }&#10;    componentDidCatch(error, errorInfo) {&#10;        console.error('ErrorBoundary caught:', error, errorInfo);&#10;    }&#10;    render() {&#10;        if (this.state.hasError) {&#10;            return (&#10;                &lt;div style={{ color: 'red', padding: '40px', background: '#fff' }}&gt;&#10;                    &lt;h2&gt;Ein Fehler ist aufgetreten!&lt;/h2&gt;&#10;                    &lt;pre&gt;{this.state.error &amp;&amp; this.state.error.toString()}&lt;/pre&gt;&#10;                &lt;/div&gt;&#10;            );&#10;        }&#10;        return this.props.children;&#10;    }&#10;}&#10;&#10;function App() {&#10;    const [gameId, setGameId] = useState('');&#10;    const [playerName, setPlayerName] = useState('');&#10;    const [isInGame, setIsInGame] = useState(false);&#10;    const [players, setPlayers] = useState([]);&#10;    const [error, setError] = useState('');&#10;    const [volume, setVolume] = useState(0.3); // Reduzierte Standard-Lautstärke&#10;&#10;    // Initialisiere AudioManager beim App-Start&#10;    useEffect(() =&gt; {&#10;        audioManager.setVolume(volume);&#10;&#10;        // Auto-start Lobby-Musik mit reduzierter Lautstärke&#10;        audioManager.playTrack('lobby.mp3', true, 2000);&#10;&#10;        // Cleanup bei App-Beendigung&#10;        return () =&gt; {&#10;            audioManager.stopTrack(500);&#10;        };&#10;    }, []);&#10;&#10;    // Volume änderungen an AudioManager weiterleiten&#10;    useEffect(() =&gt; {&#10;        audioManager.setVolume(volume);&#10;    }, [volume]);&#10;&#10;    useEffect(() =&gt; {&#10;        if (gameId) {&#10;            getGameState(gameId).then(state =&gt; {&#10;                if (state.success) {&#10;                    setPlayers(state.players || []);&#10;                }&#10;            }).catch(err =&gt; {&#10;                console.error(&quot;Fehler beim Abrufen des Spielstatus:&quot;, err);&#10;            });&#10;        }&#10;    }, [gameId, isInGame]);&#10;&#10;    const handleJoin = async (roomId, name) =&gt; {&#10;        if (!roomId || !name) {&#10;            setError('Bitte Raum-ID und Namen eingeben!');&#10;            return;&#10;        }&#10;        try {&#10;            const res = await joinGame(roomId, name);&#10;            if (res.success) {&#10;                setGameId(roomId);&#10;                setPlayerName(name);&#10;                setIsInGame(true);&#10;                setError('');&#10;            } else {&#10;                setError(res.message || 'Beitritt fehlgeschlagen');&#10;            }&#10;        } catch (e) {&#10;            setError('Serverfehler');&#10;            console.error(e);&#10;        }&#10;    };&#10;&#10;    const handleStart = async (name) =&gt; {&#10;        if (!name) {&#10;            setError('Bitte Namen eingeben!');&#10;            return;&#10;        }&#10;        try {&#10;            const res = await createGame(name);&#10;            if (res.success) {&#10;                setGameId(res.gameId);&#10;                setPlayerName(name);&#10;                setIsInGame(true);&#10;                setError('');&#10;            } else {&#10;                setError(res.message || 'Start fehlgeschlagen');&#10;            }&#10;        } catch (e) {&#10;            setError('Serverfehler');&#10;            console.error(e);&#10;        }&#10;    };&#10;&#10;    const handleLeaveGame = () =&gt; {&#10;        setIsInGame(false);&#10;        setGameId('');&#10;        setPlayers([]);&#10;        // Wechsel zurück zur Lobby-Musik&#10;        audioManager.playTrack('lobby.mp3', true, 1000);&#10;    };&#10;&#10;    const handleVolumeChange = (newVolume) =&gt; {&#10;        setVolume(newVolume);&#10;    };&#10;&#10;    return (&#10;        &lt;ErrorBoundary&gt;&#10;            &lt;div className=&quot;App&quot;&gt;&#10;                {/* VolumeControl immer sichtbar machen */}&#10;                &lt;VolumeControl volume={volume} onChange={handleVolumeChange} /&gt;&#10;&#10;                &lt;div style={{&#10;                    minHeight: '100vh',&#10;                    background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',&#10;                    padding: '20px'&#10;                }}&gt;&#10;                    &lt;div style={{ maxWidth: '800px', margin: '0 auto' }}&gt;&#10;                        {/* App Header */}&#10;                        &lt;div style={{&#10;                            textAlign: 'center',&#10;                            marginBottom: '40px',&#10;                            background: 'rgba(255,255,255,0.1)',&#10;                            padding: '30px',&#10;                            borderRadius: '20px',&#10;                            backdropFilter: 'blur(10px)',&#10;                            color: 'white',&#10;                            boxShadow: '0 8px 32px rgba(0,0,0,0.1)',&#10;                            position: 'relative'&#10;                        }}&gt;&#10;                            &lt;h1 style={{&#10;                                margin: '0 0 15px 0',&#10;                                fontSize: '42px',&#10;                                fontWeight: 'bold',&#10;                                textShadow: '3px 3px 6px rgba(0,0,0,0.3)',&#10;                                background: 'linear-gradient(45deg, #ffd700, #ffed4e)',&#10;                                WebkitBackgroundClip: 'text',&#10;                                WebkitTextFillColor: 'transparent',&#10;                                backgroundClip: 'text'&#10;                            }}&gt;&#10;                                 Don't Choose Me&#10;                            &lt;/h1&gt;&#10;                            &lt;p style={{&#10;                                margin: 0,&#10;                                fontSize: '18px',&#10;                                opacity: 0.9,&#10;                                fontWeight: '300'&#10;                            }}&gt;&#10;                                Das kreative Ratespiel für Freunde und Familie&#10;                            &lt;/p&gt;&#10;&#10;                            {/* Audio Indicator für Startseite */}&#10;                            {!isInGame &amp;&amp; (&#10;                                &lt;div style={{&#10;                                    position: 'absolute',&#10;                                    top: '15px',&#10;                                    right: '15px',&#10;                                    display: 'flex',&#10;                                    alignItems: 'center',&#10;                                    gap: '8px',&#10;                                    background: 'rgba(255,255,255,0.1)',&#10;                                    padding: '6px 12px',&#10;                                    borderRadius: '20px',&#10;                                    fontSize: '12px',&#10;                                    opacity: 0.7&#10;                                }}&gt;&#10;                                     Willkommensmusik&#10;                                &lt;/div&gt;&#10;                            )}&#10;                        &lt;/div&gt;&#10;&#10;                        {/* Main Content */}&#10;                        &lt;div style={{&#10;                            background: 'rgba(255,255,255,0.1)',&#10;                            borderRadius: '20px',&#10;                            padding: '30px',&#10;                            backdropFilter: 'blur(10px)',&#10;                            boxShadow: '0 8px 32px rgba(0,0,0,0.1)',&#10;                            border: '1px solid rgba(255,255,255,0.2)'&#10;                        }}&gt;&#10;                            {isInGame ? (&#10;                                &lt;Game&#10;                                    gameId={gameId}&#10;                                    playerName={playerName}&#10;                                    onLeaveGame={handleLeaveGame}&#10;                                    volume={volume}&#10;                                    setVolume={setVolume}&#10;                                /&gt;&#10;                            ) : (&#10;                                &lt;Lobby&#10;                                    players={players}&#10;                                    gameId={gameId}&#10;                                    error={error}&#10;                                    onJoin={handleJoin}&#10;                                    onStart={handleStart}&#10;                                    onLeave={handleLeaveGame}&#10;                                /&gt;&#10;                            )}&#10;                        &lt;/div&gt;&#10;&#10;                        {/* Footer */}&#10;                        &lt;div style={{&#10;                            textAlign: 'center',&#10;                            marginTop: '30px',&#10;                            color: 'rgba(255,255,255,0.7)',&#10;                            fontSize: '14px'&#10;                        }}&gt;&#10;                            &lt;p style={{ margin: 0 }}&gt;&#10;                                 Ein Erzähler gibt einen Hinweis zu seiner Karte&lt;br/&gt;&#10;                                 Andere wählen passende Karten aus ihrer Hand&lt;br/&gt;&#10;                                ️ Alle raten, welche Karte vom Erzähler stammt&lt;br/&gt;&#10;                                 Erste Person mit 30 Punkten gewinnt!&#10;                            &lt;/p&gt;&#10;                        &lt;/div&gt;&#10;                    &lt;/div&gt;&#10;                &lt;/div&gt;&#10;            &lt;/div&gt;&#10;        &lt;/ErrorBoundary&gt;&#10;    );&#10;}&#10;&#10;export default App;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/src/AudioManager.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/src/AudioManager.js" />
              <option name="originalContent" value="// Einfacher AudioManager für das Abspielen von Sounds&#10;class AudioManager {&#10;  constructor() {&#10;    this.currentAudio = null;&#10;    this.volume = 0.3;&#10;  }&#10;&#10;  setVolume(vol) {&#10;    this.volume = vol;&#10;    if (this.currentAudio) {&#10;      this.currentAudio.volume = vol;&#10;    }&#10;  }&#10;&#10;  playTrack(src, loop = false, fadeIn = 0) {&#10;    if (this.currentAudio) {&#10;      this.currentAudio.pause();&#10;      this.currentAudio = null;&#10;    }&#10;    const audio = new window.Audio(src);&#10;    audio.loop = loop;&#10;    audio.volume = 0;&#10;    audio.play();&#10;    this.currentAudio = audio;&#10;    if (fadeIn &gt; 0) {&#10;      let v = 0;&#10;      const step = this.volume / (fadeIn / 50);&#10;      const fade = setInterval(() =&gt; {&#10;        v += step;&#10;        audio.volume = Math.min(v, this.volume);&#10;        if (v &gt;= this.volume) clearInterval(fade);&#10;      }, 50);&#10;    } else {&#10;      audio.volume = this.volume;&#10;    }&#10;  }&#10;&#10;  playEffect(src) {&#10;    const audio = new window.Audio(src);&#10;    audio.volume = this.volume;&#10;    audio.play();&#10;  }&#10;&#10;  stopTrack(fadeOut = 0) {&#10;    if (this.currentAudio) {&#10;      if (fadeOut &gt; 0) {&#10;        let v = this.currentAudio.volume;&#10;        const step = v / (fadeOut / 50);&#10;        const fade = setInterval(() =&gt; {&#10;          v -= step;&#10;          this.currentAudio.volume = Math.max(v, 0);&#10;          if (v &lt;= 0) {&#10;            clearInterval(fade);&#10;            this.currentAudio.pause();&#10;            this.currentAudio = null;&#10;          }&#10;        }, 50);&#10;      } else {&#10;        this.currentAudio.pause();&#10;        this.currentAudio = null;&#10;      }&#10;    }&#10;  }&#10;}&#10;&#10;const audioManager = new AudioManager();&#10;export default audioManager;&#10;&#10;" />
              <option name="updatedContent" value="// Einfacher AudioManager für das Abspielen von Sounds&#13;&#10;class AudioManager {&#13;&#10;  constructor() {&#13;&#10;    this.currentAudio = null;&#13;&#10;    this.volume = 0.3;&#13;&#10;    this.isEnabled = true;&#13;&#10;    this.audioCache = new Map();&#13;&#10;    this.loadingPromises = new Map();&#13;&#10;  }&#13;&#10;&#13;&#10;  setVolume(volume) {&#13;&#10;    this.volume = Math.max(0, Math.min(1, volume));&#13;&#10;    if (this.currentAudio) {&#13;&#10;      this.currentAudio.volume = this.volume;&#13;&#10;    }&#13;&#10;  }&#13;&#10;&#13;&#10;  async loadAudio(filename) {&#13;&#10;    // Prüfen ob bereits geladen oder gerade geladen wird&#13;&#10;    if (this.audioCache.has(filename)) {&#13;&#10;      return this.audioCache.get(filename);&#13;&#10;    }&#13;&#10;    if (this.loadingPromises.has(filename)) {&#13;&#10;      return this.loadingPromises.get(filename);&#13;&#10;    }&#13;&#10;&#13;&#10;    // Audio laden&#13;&#10;    const loadPromise = new Promise((resolve, reject) =&gt; {&#13;&#10;      const audio = new Audio();&#13;&#10;&#13;&#10;      audio.addEventListener('canplaythrough', () =&gt; {&#13;&#10;        this.audioCache.set(filename, audio);&#13;&#10;        this.loadingPromises.delete(filename);&#13;&#10;        resolve(audio);&#13;&#10;      });&#13;&#10;&#13;&#10;      audio.addEventListener('error', (e) =&gt; {&#13;&#10;        console.warn(`Audio-Datei nicht gefunden: ${filename}`, e);&#13;&#10;        this.loadingPromises.delete(filename);&#13;&#10;        resolve(null); // Null zurückgeben statt Fehler werfen&#13;&#10;      });&#13;&#10;&#13;&#10;      // Versuche Audio zu laden&#13;&#10;      try {&#13;&#10;        audio.src = `/${filename}`;&#13;&#10;        audio.preload = 'auto';&#13;&#10;      } catch (error) {&#13;&#10;        console.warn(`Fehler beim Laden von ${filename}:`, error);&#13;&#10;        resolve(null);&#13;&#10;      }&#13;&#10;    });&#13;&#10;&#13;&#10;    this.loadingPromises.set(filename, loadPromise);&#13;&#10;    return loadPromise;&#13;&#10;  }&#13;&#10;&#13;&#10;  async playTrack(filename, loop = false, fadeInMs = 0) {&#13;&#10;    if (!this.isEnabled) return;&#13;&#10;&#13;&#10;    try {&#13;&#10;      // Aktuellen Track stoppen&#13;&#10;      if (this.currentAudio) {&#13;&#10;        this.stopTrack(100);&#13;&#10;      }&#13;&#10;&#13;&#10;      // Audio laden&#13;&#10;      const audio = await this.loadAudio(filename);&#13;&#10;&#13;&#10;      // Wenn Audio nicht geladen werden konnte, stumm weitermachen&#13;&#10;      if (!audio) {&#13;&#10;        console.log(`Audio ${filename} nicht verfügbar - stumme Wiedergabe`);&#13;&#10;        return;&#13;&#10;      }&#13;&#10;&#13;&#10;      this.currentAudio = audio;&#13;&#10;      audio.loop = loop;&#13;&#10;      audio.volume = fadeInMs &gt; 0 ? 0 : this.volume;&#13;&#10;&#13;&#10;      // Abspielen&#13;&#10;      await audio.play();&#13;&#10;&#13;&#10;      // Fade-in Effekt&#13;&#10;      if (fadeInMs &gt; 0) {&#13;&#10;        this.fadeIn(audio, fadeInMs);&#13;&#10;      }&#13;&#10;    } catch (error) {&#13;&#10;      console.warn(`Fehler beim Abspielen von ${filename}:`, error);&#13;&#10;      // Nicht als Fehler behandeln, sondern stumm weitermachen&#13;&#10;    }&#13;&#10;  }&#13;&#10;&#13;&#10;  fadeIn(audio, duration) {&#13;&#10;    const steps = 20;&#13;&#10;    const stepVolume = this.volume / steps;&#13;&#10;    const stepTime = duration / steps;&#13;&#10;    let currentStep = 0;&#13;&#10;&#13;&#10;    const fadeInterval = setInterval(() =&gt; {&#13;&#10;      currentStep++;&#13;&#10;      audio.volume = Math.min(stepVolume * currentStep, this.volume);&#13;&#10;&#13;&#10;      if (currentStep &gt;= steps) {&#13;&#10;        clearInterval(fadeInterval);&#13;&#10;      }&#13;&#10;    }, stepTime);&#13;&#10;  }&#13;&#10;&#13;&#10;  stopTrack(fadeOutMs = 0) {&#13;&#10;    if (!this.currentAudio) return;&#13;&#10;&#13;&#10;    if (fadeOutMs &gt; 0) {&#13;&#10;      this.fadeOut(this.currentAudio, fadeOutMs);&#13;&#10;    } else {&#13;&#10;      this.currentAudio.pause();&#13;&#10;      this.currentAudio = null;&#13;&#10;    }&#13;&#10;  }&#13;&#10;&#13;&#10;  fadeOut(audio, duration) {&#13;&#10;    const steps = 20;&#13;&#10;    const stepVolume = audio.volume / steps;&#13;&#10;    const stepTime = duration / steps;&#13;&#10;    let currentStep = 0;&#13;&#10;&#13;&#10;    const fadeInterval = setInterval(() =&gt; {&#13;&#10;      currentStep++;&#13;&#10;      audio.volume = Math.max(audio.volume - stepVolume, 0);&#13;&#10;&#13;&#10;      if (currentStep &gt;= steps || audio.volume &lt;= 0) {&#13;&#10;        clearInterval(fadeInterval);&#13;&#10;        audio.pause();&#13;&#10;        if (this.currentAudio === audio) {&#13;&#10;          this.currentAudio = null;&#13;&#10;        }&#13;&#10;      }&#13;&#10;    }, stepTime);&#13;&#10;  }&#13;&#10;&#13;&#10;  setEnabled(enabled) {&#13;&#10;    this.isEnabled = enabled;&#13;&#10;    if (!enabled &amp;&amp; this.currentAudio) {&#13;&#10;      this.stopTrack(100);&#13;&#10;    }&#13;&#10;  }&#13;&#10;}&#13;&#10;&#13;&#10;// Singleton-Instanz exportieren&#13;&#10;const audioManager = new AudioManager();&#13;&#10;export default audioManager;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/src/api.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/src/api.js" />
              <option name="originalContent" value="import config from './config.json';&#10;&#10;// API-Client für die Kommunikation mit dem PHP-Backend&#10;const API_URL = config.API_URL; // Passe ggf. den Pfad an&#10;&#10;// Hilfsfunktion zum sicheren Parsen von JSON-Antworten&#10;async function parseJSONResponse(response) {&#10;  try {&#10;    // Prüfen, ob die Antwort erfolgreich war&#10;    if (!response.ok) {&#10;      // Bei 500er Fehlern versuchen wir trotzdem, die Antwort zu lesen&#10;      if (response.status === 500) {&#10;        try {&#10;          const text = await response.text();&#10;          console.error('Server-Fehler (500):', text);&#10;          return { success: false, message: `Server-Fehler: ${text}` };&#10;        } catch {&#10;          return { success: false, message: 'Server-Fehler (500): Keine Details verfügbar' };&#10;        }&#10;      }&#10;      throw new Error(`HTTP error! Status: ${response.status}`);&#10;    }&#10;&#10;    // Text der Antwort lesen&#10;    const text = await response.text();&#10;&#10;    // Wenn der Text leer ist, geben wir ein leeres Objekt zurück&#10;    if (!text || text.trim() === '') {&#10;      console.warn('Leere Antwort vom Server erhalten');&#10;      return { success: false, message: 'Leere Antwort vom Server' };&#10;    }&#10;&#10;    // Versuchen, den Text als JSON zu parsen&#10;    try {&#10;      return JSON.parse(text);&#10;    } catch (jsonError) {&#10;      console.error('JSON-Parsing-Fehler:', jsonError);&#10;      console.error('Erhaltener Text:', text);&#10;      throw new Error('Ungültiges JSON vom Server erhalten');&#10;    }&#10;  } catch (error) {&#10;    console.error('API-Anfragefehler:', error);&#10;    return { success: false, message: `API-Fehler: ${error.message}` };&#10;  }&#10;}&#10;&#10;export async function createGame(playerName) {&#10;  try {&#10;    const res = await fetch(`${API_URL}/Lobby.php`, {&#10;      method: 'POST',&#10;      headers: { 'Content-Type': 'application/json' },&#10;      body: JSON.stringify({ playerName })&#10;    });&#10;    return parseJSONResponse(res);&#10;  } catch (error) {&#10;    console.error('Fehler beim Erstellen des Spiels:', error);&#10;    return { success: false, message: 'Verbindungsfehler: Bitte überprüfe deine Internetverbindung' };&#10;  }&#10;}&#10;&#10;export async function joinGame(gameId, playerName) {&#10;  try {&#10;    const res = await fetch(`${API_URL}/Lobby.php`, {&#10;      method: 'POST',&#10;      headers: { 'Content-Type': 'application/json' },&#10;      body: JSON.stringify({ gameId, playerName })&#10;    });&#10;    return parseJSONResponse(res);&#10;  } catch (error) {&#10;    console.error('Fehler beim Beitreten des Spiels:', error);&#10;    return { success: false, message: 'Verbindungsfehler: Bitte überprüfe deine Internetverbindung' };&#10;  }&#10;}&#10;&#10;export async function getGameState(gameId) {&#10;  try {&#10;    const res = await fetch(`${API_URL}/Game_api.php?gameId=${gameId}`);&#10;    return parseJSONResponse(res);&#10;  } catch (error) {&#10;    console.error('Fehler beim Abrufen des Spielstatus:', error);&#10;    return { success: false, message: 'Verbindungsfehler: Bitte überprüfe deine Internetverbindung' };&#10;  }&#10;}&#10;&#10;export async function giveHint(gameId, playerName, cardId, hint) {&#10;  try {&#10;    const res = await fetch(`${API_URL}/Game_api.php`, {&#10;      method: 'POST',&#10;      headers: { 'Content-Type': 'application/json' },&#10;      body: JSON.stringify({ gameId, playerName, cardId, hint, action: 'giveHint' })&#10;    });&#10;    return parseJSONResponse(res);&#10;  } catch (error) {&#10;    console.error('Fehler beim Senden des Hinweises:', error);&#10;    return { success: false, message: 'Verbindungsfehler: Bitte überprüfe deine Internetverbindung' };&#10;  }&#10;}&#10;&#10;export async function chooseCard(gameId, playerName, cardId) {&#10;  try {&#10;    const res = await fetch(`${API_URL}/Game_api.php`, {&#10;      method: 'POST',&#10;      headers: { 'Content-Type': 'application/json' },&#10;      body: JSON.stringify({ gameId, playerName, cardId, action: 'chooseCard' })&#10;    });&#10;    return parseJSONResponse(res);&#10;  } catch (error) {&#10;    console.error('Fehler beim Auswählen einer Karte:', error);&#10;    return { success: false, message: 'Verbindungsfehler: Bitte überprüfe deine Internetverbindung' };&#10;  }&#10;}&#10;&#10;export async function vote(gameId, playerName, cardId) {&#10;  try {&#10;    const res = await fetch(`${API_URL}/Game_api.php`, {&#10;      method: 'POST',&#10;      headers: { 'Content-Type': 'application/json' },&#10;      body: JSON.stringify({ gameId, playerName, cardId, action: 'vote' })&#10;    });&#10;    return parseJSONResponse(res);&#10;  } catch (error) {&#10;    console.error('Fehler beim Abstimmen:', error);&#10;    return { success: false, message: 'Verbindungsfehler: Bitte überprüfe deine Internetverbindung' };&#10;  }&#10;}&#10;&#10;export async function nextRound(gameId) {&#10;  try {&#10;    const res = await fetch(`${API_URL}/Game_api.php`, {&#10;      method: 'POST',&#10;      headers: { 'Content-Type': 'application/json' },&#10;      body: JSON.stringify({ gameId, action: 'nextRound' })&#10;    });&#10;    return parseJSONResponse(res);&#10;  } catch (error) {&#10;    console.error('Fehler beim Starten der nächsten Runde:', error);&#10;    return { success: false, message: 'Verbindungsfehler: Bitte überprüfe deine Internetverbindung' };&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import config from './config.json';&#10;&#10;// API-Client für die Kommunikation mit dem PHP-Backend&#10;const API_URL = config.API_URL; // Passe ggf. den Pfad an&#10;&#10;// Hilfsfunktion zum sicheren Parsen von JSON-Antworten&#10;async function parseJSONResponse(response) {&#10;  try {&#10;    // Prüfen, ob die Antwort erfolgreich war&#10;    if (!response.ok) {&#10;      // Bei 500er Fehlern versuchen wir trotzdem, die Antwort zu lesen&#10;      if (response.status === 500) {&#10;        try {&#10;          const text = await response.text();&#10;          console.error('Server-Fehler (500):', text);&#10;          return { success: false, message: `Server-Fehler: ${text}` };&#10;        } catch {&#10;          return { success: false, message: 'Server-Fehler (500): Keine Details verfügbar' };&#10;        }&#10;      }&#10;      throw new Error(`HTTP error! Status: ${response.status}`);&#10;    }&#10;&#10;    // Text der Antwort lesen&#10;    const text = await response.text();&#10;&#10;    // Wenn der Text leer ist, geben wir ein leeres Objekt zurück&#10;    if (!text || text.trim() === '') {&#10;      console.warn('Leere Antwort vom Server erhalten');&#10;      return { success: false, message: 'Leere Antwort vom Server' };&#10;    }&#10;&#10;    // Versuchen, den Text als JSON zu parsen&#10;    try {&#10;      return JSON.parse(text);&#10;    } catch (jsonError) {&#10;      console.error('JSON-Parsing-Fehler:', jsonError);&#10;      console.error('Erhaltener Text:', text);&#10;      throw new Error('Ungültiges JSON vom Server erhalten');&#10;    }&#10;  } catch (error) {&#10;    console.error('API-Anfragefehler:', error);&#10;    return { success: false, message: `API-Fehler: ${error.message}` };&#10;  }&#10;}&#10;&#10;export async function createGame(playerName) {&#10;  try {&#10;    const res = await fetch(`${API_URL}/Lobby.php`, {&#10;      method: 'POST',&#10;      headers: { &#10;        'Content-Type': 'application/json'&#10;      },&#10;      mode: 'cors',&#10;      body: JSON.stringify({ playerName })&#10;    });&#10;    return parseJSONResponse(res);&#10;  } catch (error) {&#10;    console.error('Fehler beim Erstellen des Spiels:', error);&#10;    return { success: false, message: 'Verbindungsfehler: Bitte überprüfe deine Internetverbindung' };&#10;  }&#10;}&#10;&#10;export async function joinGame(gameId, playerName) {&#10;  try {&#10;    const res = await fetch(`${API_URL}/Lobby.php`, {&#10;      method: 'POST',&#10;      headers: { &#10;        'Content-Type': 'application/json'&#10;      },&#10;      mode: 'cors',&#10;      body: JSON.stringify({ gameId, playerName })&#10;    });&#10;    return parseJSONResponse(res);&#10;  } catch (error) {&#10;    console.error('Fehler beim Beitreten des Spiels:', error);&#10;    return { success: false, message: 'Verbindungsfehler: Bitte überprüfe deine Internetverbindung' };&#10;  }&#10;}&#10;&#10;export async function getGameState(gameId) {&#10;  try {&#10;    const res = await fetch(`${API_URL}/Game_api.php?gameId=${gameId}`);&#10;    return parseJSONResponse(res);&#10;  } catch (error) {&#10;    console.error('Fehler beim Abrufen des Spielstatus:', error);&#10;    return { success: false, message: 'Verbindungsfehler: Bitte überprüfe deine Internetverbindung' };&#10;  }&#10;}&#10;&#10;export async function giveHint(gameId, playerName, cardId, hint) {&#10;  try {&#10;    const res = await fetch(`${API_URL}/Game_api.php`, {&#10;      method: 'POST',&#10;      headers: { 'Content-Type': 'application/json' },&#10;      body: JSON.stringify({ gameId, playerName, cardId, hint, action: 'giveHint' })&#10;    });&#10;    return parseJSONResponse(res);&#10;  } catch (error) {&#10;    console.error('Fehler beim Senden des Hinweises:', error);&#10;    return { success: false, message: 'Verbindungsfehler: Bitte überprüfe deine Internetverbindung' };&#10;  }&#10;}&#10;&#10;export async function chooseCard(gameId, playerName, cardId) {&#10;  try {&#10;    const res = await fetch(`${API_URL}/Game_api.php`, {&#10;      method: 'POST',&#10;      headers: { 'Content-Type': 'application/json' },&#10;      body: JSON.stringify({ gameId, playerName, cardId, action: 'chooseCard' })&#10;    });&#10;    return parseJSONResponse(res);&#10;  } catch (error) {&#10;    console.error('Fehler beim Auswählen einer Karte:', error);&#10;    return { success: false, message: 'Verbindungsfehler: Bitte überprüfe deine Internetverbindung' };&#10;  }&#10;}&#10;&#10;export async function vote(gameId, playerName, cardId) {&#10;  try {&#10;    const res = await fetch(`${API_URL}/Game_api.php`, {&#10;      method: 'POST',&#10;      headers: { 'Content-Type': 'application/json' },&#10;      body: JSON.stringify({ gameId, playerName, cardId, action: 'vote' })&#10;    });&#10;    return parseJSONResponse(res);&#10;  } catch (error) {&#10;    console.error('Fehler beim Abstimmen:', error);&#10;    return { success: false, message: 'Verbindungsfehler: Bitte überprüfe deine Internetverbindung' };&#10;  }&#10;}&#10;&#10;export async function nextRound(gameId) {&#10;  try {&#10;    const res = await fetch(`${API_URL}/Game_api.php`, {&#10;      method: 'POST',&#10;      headers: { 'Content-Type': 'application/json' },&#10;      body: JSON.stringify({ gameId, action: 'nextRound' })&#10;    });&#10;    return parseJSONResponse(res);&#10;  } catch (error) {&#10;    console.error('Fehler beim Starten der nächsten Runde:', error);&#10;    return { success: false, message: 'Verbindungsfehler: Bitte überprüfe deine Internetverbindung' };&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>